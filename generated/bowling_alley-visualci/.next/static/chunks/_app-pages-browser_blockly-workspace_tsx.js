"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_blockly-workspace_tsx"],{

/***/ "(app-pages-browser)/./blockly-code-generator.tsx":
/*!************************************!*\
  !*** ./blockly-code-generator.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EcoreGenerator: () => (/* binding */ EcoreGenerator)\n/* harmony export */ });\n// Code generator for Ecore blocks\n// This file contains the code generator for the Ecore blocks\nlet generatorInitialized = false;\n// Add this at the top of the file, after the generatorInitialized variable\nfunction generateRandomId() {\n    return Math.floor(10000 + Math.random() * 90000).toString();\n}\nclass EcoreGenerator {\n    // Initialize the generator\n    static init() {\n        // Prevent multiple initializations\n        if (generatorInitialized) {\n            return;\n        }\n        // Create a namespace for our generator functions\n        if (!window.Blockly.Ecore) {\n            window.Blockly.Ecore = {};\n        }\n        // Define generator functions for each block type\n        this.defineGenerators();\n        // Mark as initialized\n        generatorInitialized = true;\n        console.log(\"Ecore generator initialized successfully\");\n    }\n    // Define generator functions for all block types\n    static defineGenerators() {\n        const Ecore = window.Blockly.Ecore;\n        // Pipeline block generator\n        Ecore[\"ecore_pipeline\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"default_pipeline\";\n            const concurrent = block.getFieldValue(\"ATTR_CONCURRENT\") === \"TRUE\";\n            // Get connected blocks\n            const whenBlock = block.getInputTargetBlock(\"CONT_WHEN\");\n            const jobBlock = block.getInputTargetBlock(\"CONT_JOB\");\n            const toolBlock = block.getInputTargetBlock(\"CONT_TOOL\");\n            const envBlock = block.getInputTargetBlock(\"CONT_ENVIRONMENT\");\n            const permBlock = block.getInputTargetBlock(\"CONT_PERMISSION\");\n            // Generate code with proper indentation\n            let code = \"# Pipeline: \".concat(name, \"\\n\");\n            code += \"name: \".concat(name, \"\\n\");\n            // Only include concurrent if it's true\n            if (concurrent) {\n                code += \"concurrent: \".concat(concurrent, \"\\n\");\n            }\n            code += \"\\n\";\n            // Add when blocks if present\n            if (whenBlock) {\n                const whenCode = window.Blockly.Ecore.blockToCode(whenBlock);\n                code += whenCode;\n            }\n            // Add job blocks if present\n            if (jobBlock) {\n                code += \"jobs:\\n\";\n                const jobCode = window.Blockly.Ecore.blockToCode(jobBlock);\n                code += jobCode;\n            }\n            // Add tool blocks if present\n            if (toolBlock) {\n                code += \"tools:\\n\";\n                const toolCode = window.Blockly.Ecore.blockToCode(toolBlock);\n                code += toolCode;\n            }\n            // Add environment blocks if present\n            if (envBlock) {\n                code += \"env:\\n\";\n                const envCode = window.Blockly.Ecore.blockToCode(envBlock);\n                code += envCode;\n            }\n            // Add permission blocks if present\n            if (permBlock) {\n                code += \"permissions:\\n\";\n                const permCode = window.Blockly.Ecore.blockToCode(permBlock);\n                code += permCode;\n            }\n            return code;\n        };\n        // Job block generator\n        Ecore[\"ecore_job\"] = (block)=>{\n            let name = block.getFieldValue(\"ATTR_NAME\");\n            if (!name || name.trim() === \"\") {\n                name = \"job_\".concat(generateRandomId());\n            }\n            const allowFailure = block.getFieldValue(\"ATTR_ALLOWFAILURE\") === \"TRUE\";\n            // We're not using the description as requested\n            // const description = block.getFieldValue(\"ATTR_DESCRIPTION\") || \"\"\n            // Get connected blocks\n            const toolBlock = block.getInputTargetBlock(\"CONT_TOOL\");\n            const commandBlock = block.getInputTargetBlock(\"CONT_COMMAND\");\n            const ifThenElseBlock = block.getInputTargetBlock(\"CONT_IFTHENELSE\");\n            const inputBlock = block.getInputTargetBlock(\"CONT_INPUT\");\n            const envBlock = block.getInputTargetBlock(\"CONT_ENVIRONMENT\");\n            const permBlock = block.getInputTargetBlock(\"CONT_PERMISSION\");\n            const outputBlock = block.getInputTargetBlock(\"REL_OUTPUT\");\n            const dependsBlock = block.getInputTargetBlock(\"REL_DEPENDS\");\n            // Generate code with proper indentation\n            let code = \"  \".concat(name, \":\\n\");\n            // Include description as a comment if it exists\n            const description = block.getFieldValue(\"ATTR_DESCRIPTION\") || \"\";\n            if (description) {\n                code += \"    # \".concat(description, \"\\n\");\n            }\n            // Use the tool name for runs-on if a tool is present\n            if (toolBlock) {\n                const toolName = toolBlock.getFieldValue(\"ATTR_NAME\");\n                if (toolName) {\n                    code += \"    runs-on: \".concat(toolName, \"\\n\");\n                }\n            }\n            // Only add continue-on-error if it's true\n            if (allowFailure) {\n                code += \"    continue-on-error: \".concat(allowFailure, \"\\n\");\n            }\n            // Add command blocks if present\n            if (commandBlock) {\n                code += \"    steps:\\n\";\n                const commandCode = window.Blockly.Ecore.blockToCode(commandBlock);\n                // Increase indentation for nested blocks\n                code += indentCode(commandCode, 3);\n            }\n            // Add ifThenElse blocks if present\n            if (ifThenElseBlock) {\n                code += \"    if:\\n\";\n                const ifThenElseCode = window.Blockly.Ecore.blockToCode(ifThenElseBlock);\n                // Increase indentation for nested blocks\n                code += indentCode(ifThenElseCode, 3);\n            }\n            // Add input blocks if present\n            if (inputBlock) {\n                code += \"    inputs:\\n\";\n                const inputCode = window.Blockly.Ecore.blockToCode(inputBlock);\n                // Increase indentation for nested blocks\n                code += indentCode(inputCode, 3);\n            }\n            // Add environment blocks if present\n            if (envBlock) {\n                code += \"    env:\\n\";\n                const envCode = window.Blockly.Ecore.blockToCode(envBlock);\n                // Increase indentation for nested blocks\n                code += indentCode(envCode, 3);\n            }\n            // Add permission blocks if present\n            if (permBlock) {\n                code += \"    permissions:\\n\";\n                const permCode = window.Blockly.Ecore.blockToCode(permBlock);\n                // Increase indentation for nested blocks\n                code += indentCode(permCode, 3);\n            }\n            // Add output blocks if present\n            if (outputBlock) {\n                const outputCode = window.Blockly.Ecore.blockToCode(outputBlock);\n                code += \"    outputs:\\n      - \".concat(outputCode.trim(), \"\\n\");\n            }\n            // Add depends blocks if present\n            if (dependsBlock) {\n                const dependsCode = window.Blockly.Ecore.blockToCode(dependsBlock);\n                code += \"    needs: [\".concat(dependsCode, \"]\\n\");\n            }\n            // Check for next job block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Job value block generator\n        Ecore[\"ecore_job_value\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_job\";\n            return '\"'.concat(name, '\"');\n        };\n        // Command block generator\n        Ecore[\"ecore_command\"] = (block)=>{\n            let name = block.getFieldValue(\"ATTR_NAME\");\n            if (!name || name.trim() === \"\") {\n                name = \"command_\".concat(generateRandomId());\n            }\n            // Get connected blocks\n            const toolBlock = block.getInputTargetBlock(\"CONT_TOOL\");\n            const paramBlock = block.getInputTargetBlock(\"CONT_PARAMETER\");\n            const dependsBlock = block.getInputTargetBlock(\"REL_DEPENDS\");\n            // Generate code with proper indentation\n            let code = \"      - name: \".concat(name, \"\\n\");\n            // Add tool blocks if present\n            if (toolBlock) {\n                const toolCode = window.Blockly.Ecore.blockToCode(toolBlock);\n                const toolValue = toolCode.trim().replace(/\"/g, \"\") // Remove quotes\n                ;\n                // Check if this is a shell command (denoted by \"|\")\n                if (toolValue === \"|\") {\n                    // This is a shell command using |\n                    code += \"        run: |\\n\";\n                    // Add default shell command if no parameters are provided\n                    if (!paramBlock) {\n                        code += '          echo \"Running shell commands\"\\n';\n                        code += '          echo \"Current directory: $(pwd)\"\\n';\n                    } else {\n                        // For shell commands with parameters, we need to ensure each parameter is on a new line with correct indentation\n                        const paramCode = window.Blockly.Ecore.processShellParameters(paramBlock);\n                        code += paramCode;\n                    }\n                } else if (toolValue.includes(\"actions/\") || toolValue.includes(\"@v\")) {\n                    // This is a GitHub Actions tool - use the exact toolValue without modification\n                    code += \"        uses: \".concat(toolValue, \"\\n\");\n                    // Add appropriate default parameters based on the tool\n                    if (toolValue.includes(\"setup-python\") && !paramBlock) {\n                        code += \"        with:\\n\";\n                        code += \"          python-version: '3.x'  # Uses the latest stable 3.x version\\n\";\n                    } else if (toolValue.includes(\"setup-node\") && !paramBlock) {\n                        code += \"        with:\\n\";\n                        code += \"          node-version: '18.x'\\n\";\n                    } else if (toolValue.includes(\"setup-java\") && !paramBlock) {\n                        code += \"        with:\\n\";\n                        code += \"          distribution: 'temurin'\\n\";\n                        code += \"          java-version: '17'\\n\";\n                    } else if (paramBlock) {\n                        code += \"        with:\\n\";\n                        const paramCode = window.Blockly.Ecore.blockToCode(paramBlock);\n                        // Increase indentation for nested blocks\n                        code += indentCode(paramCode, 4);\n                    }\n                } else {\n                    // Regular tool - like yarn, npm, etc.\n                    let command = toolValue;\n                    // Add parameters in a single line with single space between them\n                    if (paramBlock) {\n                        // Get parameters and add them to the command\n                        const paramCode = window.Blockly.Ecore.processRegularParameters(paramBlock);\n                        command += \" \" + paramCode;\n                    }\n                    // Add the run command\n                    code += \"        run: \".concat(command, \"\\n\");\n                }\n            }\n            // Add depends blocks if present\n            if (dependsBlock) {\n                const dependsCode = window.Blockly.Ecore.blockToCode(dependsBlock);\n                code += \"        needs: [\".concat(dependsCode, \"]\\n\");\n            }\n            // Check for next command block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Command value block generator\n        Ecore[\"ecore_command_value\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_command\";\n            return '\"'.concat(name, '\"');\n        };\n        // Environment block generator\n        Ecore[\"ecore_environment\"] = (block)=>{\n            const key = block.getFieldValue(\"ATTR_KEY\") || \"ENV_KEY\";\n            const value = block.getFieldValue(\"ATTR_VALUE\") || \"value\";\n            // Generate code with proper indentation\n            let code = \"  \".concat(key, ': \"').concat(value, '\"\\n');\n            // Check for next environment block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // When block generator\n        Ecore[\"ecore_when\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_trigger\";\n            const trigger = block.getFieldValue(\"ATTR_TRIGGER\") || \"\";\n            const timer = block.getFieldValue(\"ATTR_TIMER\") || \"\";\n            // Generate code with proper indentation\n            let code = \"on:\\n\";\n            // Handle workflow_dispatch trigger\n            if (trigger === \"workflow_dispatch\") {\n                code += \"  workflow_dispatch:\\n\";\n            } else if (trigger) {\n                code += \"  \".concat(trigger, \":\\n\");\n                code += \"    branches: [main]\\n\";\n            }\n            // Handle scheduled triggers\n            if (timer) {\n                code += \"  schedule:\\n\";\n                code += '    - cron: \"'.concat(timer, '\"\\n');\n            }\n            code += \"\\n\";\n            // Check for next when block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Artifact block generator\n        Ecore[\"ecore_artifact\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_artifact\";\n            // For statement blocks, return full code\n            let code = \"      - name: \".concat(name, \"\\n\");\n            // Check for next artifact block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Artifact value block generator\n        Ecore[\"ecore_artifact_value\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_artifact\";\n            return '\"'.concat(name, '\"');\n        };\n        // Job Tool block generator\n        Ecore[\"ecore_tool\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_tool\";\n            // For statement blocks, return full code\n            let code = \"      - \".concat(name, \"\\n\");\n            // Check for next tool block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Command Tool value block generator\n        Ecore[\"ecore_tool_value\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_tool\";\n            // Check if this is a shell command indicator\n            if (name === \"|\") {\n                return '\"|\"';\n            }\n            // Check if this is a GitHub Action (either starts with \"actions/\" or contains \"@v\")\n            if (name.startsWith(\"actions/\") || name.includes(\"@v\")) {\n                // Return the name as is - no special handling for different formats\n                return '\"'.concat(name, '\"');\n            }\n            return '\"'.concat(name, '\"');\n        };\n        // IfThenElse block generator\n        Ecore[\"ecore_ifthenelse\"] = (block)=>{\n            const condition = block.getFieldValue(\"ATTR_CONDITION\") || \"true\";\n            // Get connected blocks\n            const trueBlock = block.getInputTargetBlock(\"CONT_TRUE\");\n            const falseBlock = block.getInputTargetBlock(\"CONT_FALSE\");\n            // Generate code for GitHub Actions if conditions\n            let code = \"\";\n            // Add true branch if present\n            if (trueBlock) {\n                // Generate code for the true branch\n                const trueCode = window.Blockly.Ecore.blockToCode(trueBlock);\n                // Insert the condition after each \"- name:\" line\n                const lines = trueCode.split(\"\\n\");\n                let processedCode = \"\";\n                for(let i = 0; i < lines.length; i++){\n                    processedCode += lines[i] + \"\\n\";\n                    // If this is a \"- name:\" line, add the condition on the next line\n                    if (lines[i].trim().startsWith(\"- name:\") && i + 1 < lines.length) {\n                        // Insert condition before the next line (which is typically 'uses:' or 'run:')\n                        processedCode += \"        if: \".concat(condition, \"\\n\");\n                    }\n                }\n                code += processedCode;\n            }\n            // Add false branch if present\n            if (falseBlock) {\n                // Generate code for the false branch, with inverted condition\n                const invertedCondition = \"!(\".concat(condition, \")\");\n                const falseCode = window.Blockly.Ecore.blockToCode(falseBlock);\n                // Insert the inverted condition after each \"- name:\" line\n                const lines = falseCode.split(\"\\n\");\n                let processedCode = \"\";\n                for(let i = 0; i < lines.length; i++){\n                    processedCode += lines[i] + \"\\n\";\n                    // If this is a \"- name:\" line, add the inverted condition on the next line\n                    if (lines[i].trim().startsWith(\"- name:\") && i + 1 < lines.length) {\n                        // Insert inverted condition before the next line (which is typically 'uses:' or 'run:')\n                        processedCode += \"        if: \".concat(invertedCondition, \"\\n\");\n                    }\n                }\n                code += processedCode;\n            }\n            // Check for next block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // If block generator\n        Ecore[\"ecore_if\"] = (block)=>{\n            // Get connected blocks\n            const commandBlock = block.getInputTargetBlock(\"CONT_COMMAND\");\n            const ifThenElseBlock = block.getInputTargetBlock(\"CONT_IFTHENELSE\");\n            // Generate code\n            let code = \"\";\n            // Add command blocks if present\n            if (commandBlock) {\n                const commandCode = window.Blockly.Ecore.blockToCode(commandBlock);\n                code += commandCode;\n            }\n            // Add ifThenElse blocks if present\n            if (ifThenElseBlock) {\n                const ifThenElseCode = window.Blockly.Ecore.blockToCode(ifThenElseBlock);\n                code += ifThenElseCode;\n            }\n            return code;\n        };\n        // Else block generator\n        Ecore[\"ecore_else\"] = (block)=>{\n            // Get connected blocks\n            const commandBlock = block.getInputTargetBlock(\"CONT_COMMAND\");\n            const ifThenElseBlock = block.getInputTargetBlock(\"CONT_IFTHENELSE\");\n            // Generate code\n            let code = \"\";\n            // Add command blocks if present\n            if (commandBlock) {\n                const commandCode = window.Blockly.Ecore.blockToCode(commandBlock);\n                code += commandCode;\n            }\n            // Add ifThenElse blocks if present\n            if (ifThenElseBlock) {\n                const ifThenElseCode = window.Blockly.Ecore.blockToCode(ifThenElseBlock);\n                code += ifThenElseCode;\n            }\n            return code;\n        };\n        // Parameter block generator\n        Ecore[\"ecore_parameter\"] = (block)=>{\n            const parameter = block.getFieldValue(\"ATTR_PARAMETER\") || \"param\";\n            // Get the parent block\n            const parentBlock = block.getParent();\n            // Check if parent is a command block and its tool is \"|\"\n            let isShellCommand = false;\n            let isRegularCommand = false;\n            if (parentBlock && parentBlock.type === \"ecore_command\") {\n                const toolBlock = parentBlock.getInputTargetBlock(\"CONT_TOOL\");\n                if (toolBlock && toolBlock.type === \"ecore_tool_value\") {\n                    const toolName = toolBlock.getFieldValue(\"ATTR_NAME\");\n                    isShellCommand = toolName === \"|\";\n                    isRegularCommand = toolName !== \"|\" && !toolName.includes(\"actions/\") && !toolName.includes(\"@v\");\n                }\n            }\n            // Generate code with proper indentation based on parent\n            let code;\n            if (isShellCommand) {\n                // For shell commands, each parameter is a new line of the script\n                code = \"          \".concat(parameter, \"\\n\");\n            } else if (isRegularCommand) {\n                // For regular commands like yarn, just return the parameter\n                code = \"\".concat(parameter);\n            } else {\n                // Regular parameter format for \"with:\" sections\n                code = \"          \".concat(parameter, \"\\n\");\n            }\n            // Check for next parameter block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Add a special function to handle shell command parameters\n        Ecore.processShellParameters = (paramBlock)=>{\n            if (!paramBlock) {\n                return \"\";\n            }\n            // Get all parameters as a single string\n            const paramCode = window.Blockly.Ecore.blockToCode(paramBlock);\n            // Split into lines and indent each line properly\n            const paramLines = paramCode.split(\"\\n\");\n            let indentedParams = \"\";\n            for (const line of paramLines){\n                if (line.trim()) {\n                    // Add exactly 10 spaces (8 spaces + 2 for proper level) for each shell command\n                    indentedParams += \"          \".concat(line.trim(), \"\\n\");\n                }\n            }\n            return indentedParams;\n        };\n        // Add a special function to handle regular command parameters\n        Ecore.processRegularParameters = (paramBlock)=>{\n            if (!paramBlock) {\n                return \"\";\n            }\n            // Get all parameters as a single string\n            const paramCode = window.Blockly.Ecore.blockToCode(paramBlock);\n            // Split into lines and join with a single space\n            const params = paramCode.trim().split(\"\\n\").filter((line)=>line.trim()).map((line)=>line.trim()).join(\" \");\n            return params;\n        };\n        // Permission block generator\n        Ecore[\"ecore_permission\"] = (block)=>{\n            const key = block.getFieldValue(\"ATTR_KEY\") || \"PERM_KEY\";\n            const value = block.getFieldValue(\"ATTR_VALUE\") || \"value\";\n            // Generate code with proper indentation\n            let code = \"  \".concat(key, \": \").concat(value, \"\\n\");\n            // Check for next permission block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += nextCode;\n            }\n            return code;\n        };\n        // Job dependency block generator\n        Ecore[\"ecore_job_dependency\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_job\";\n            // Start with the current job name\n            let code = '\"'.concat(name, '\"');\n            // Check for next dependency block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += \", \".concat(nextCode);\n            }\n            return code;\n        };\n        // Command dependency block generator\n        Ecore[\"ecore_command_dependency\"] = (block)=>{\n            const name = block.getFieldValue(\"ATTR_NAME\") || \"unnamed_command\";\n            // Start with the current command name\n            let code = '\"'.concat(name, '\"');\n            // Check for next dependency block\n            const nextBlock = block.getNextBlock();\n            if (nextBlock) {\n                const nextCode = window.Blockly.Ecore.blockToCode(nextBlock);\n                code += \", \".concat(nextCode);\n            }\n            return code;\n        };\n        // Add a blockToCode function to handle any block\n        Ecore.blockToCode = (block)=>{\n            if (!block) {\n                return \"\";\n            }\n            // Check if there's a generator for this block type\n            if (Ecore[block.type]) {\n                return Ecore[block.type](block);\n            }\n            // Default case if no generator is found\n            console.warn(\"No generator found for block type: \".concat(block.type));\n            return \"\";\n        };\n    }\n    // Generate code from the workspace\n    static generateCode(workspace) {\n        // Make sure generators are initialized\n        this.init();\n        // Get all top-level blocks\n        const topBlocks = workspace.getTopBlocks(true);\n        // Generate code for each top-level block\n        let code = \"# Generated CI/CD Pipeline YAML\\n\";\n        code += \"# This YAML is compatible with GitHub Actions\\n\\n\";\n        for (const block of topBlocks){\n            if (window.Blockly.Ecore[block.type]) {\n                code += window.Blockly.Ecore.blockToCode(block);\n            }\n        }\n        return code;\n    }\n}\n// Helper function to indent code\nfunction indentCode(code, indentLevel) {\n    const indent = \"  \".repeat(indentLevel);\n    return code.split(\"\\n\").map((line)=>{\n        if (line.trim() === \"\") return line;\n        return indent + line;\n    }).join(\"\\n\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2Jsb2NrbHktY29kZS1nZW5lcmF0b3IudHN4IiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrQ0FBa0M7QUFDbEMsNkRBQTZEO0FBRTdELElBQUlBLHVCQUF1QjtBQUUzQiwyRUFBMkU7QUFDM0UsU0FBU0M7SUFDUCxPQUFPQyxLQUFLQyxLQUFLLENBQUMsUUFBUUQsS0FBS0UsTUFBTSxLQUFLLE9BQU9DLFFBQVE7QUFDM0Q7QUFFTyxNQUFNQztJQUNYLDJCQUEyQjtJQUMzQixPQUFPQyxPQUFPO1FBQ1osbUNBQW1DO1FBQ25DLElBQUlQLHNCQUFzQjtZQUN4QjtRQUNGO1FBRUEsaURBQWlEO1FBQ2pELElBQUksQ0FBQ1EsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLEVBQUU7WUFDekJGLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHLENBQUM7UUFDMUI7UUFFQSxpREFBaUQ7UUFDakQsSUFBSSxDQUFDQyxnQkFBZ0I7UUFFckIsc0JBQXNCO1FBQ3RCWCx1QkFBdUI7UUFDdkJZLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUEsaURBQWlEO0lBQ2pELE9BQU9GLG1CQUFtQjtRQUN4QixNQUFNRCxRQUFRRixPQUFPQyxPQUFPLENBQUNDLEtBQUs7UUFFbEMsMkJBQTJCO1FBQzNCQSxLQUFLLENBQUMsaUJBQWlCLEdBQUcsQ0FBQ0k7WUFDekIsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUNqRCxNQUFNQyxhQUFhSCxNQUFNRSxhQUFhLENBQUMsdUJBQXVCO1lBRTlELHVCQUF1QjtZQUN2QixNQUFNRSxZQUFZSixNQUFNSyxtQkFBbUIsQ0FBQztZQUM1QyxNQUFNQyxXQUFXTixNQUFNSyxtQkFBbUIsQ0FBQztZQUMzQyxNQUFNRSxZQUFZUCxNQUFNSyxtQkFBbUIsQ0FBQztZQUM1QyxNQUFNRyxXQUFXUixNQUFNSyxtQkFBbUIsQ0FBQztZQUMzQyxNQUFNSSxZQUFZVCxNQUFNSyxtQkFBbUIsQ0FBQztZQUU1Qyx3Q0FBd0M7WUFDeEMsSUFBSUssT0FBTyxlQUFvQixPQUFMVCxNQUFLO1lBQy9CUyxRQUFRLFNBQWMsT0FBTFQsTUFBSztZQUN0Qix1Q0FBdUM7WUFDdkMsSUFBSUUsWUFBWTtnQkFDZE8sUUFBUSxlQUEwQixPQUFYUCxZQUFXO1lBQ3BDO1lBRUFPLFFBQVM7WUFFVCw2QkFBNkI7WUFDN0IsSUFBSU4sV0FBVztnQkFDYixNQUFNTyxXQUFXakIsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNSO2dCQUNsRE0sUUFBUUM7WUFDVjtZQUVBLDRCQUE0QjtZQUM1QixJQUFJTCxVQUFVO2dCQUNaSSxRQUFRO2dCQUNSLE1BQU1HLFVBQVVuQixPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ047Z0JBQ2pESSxRQUFRRztZQUNWO1lBRUEsNkJBQTZCO1lBQzdCLElBQUlOLFdBQVc7Z0JBQ2JHLFFBQVE7Z0JBQ1IsTUFBTUksV0FBV3BCLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDTDtnQkFDbERHLFFBQVFJO1lBQ1Y7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSU4sVUFBVTtnQkFDWkUsUUFBUTtnQkFDUixNQUFNSyxVQUFVckIsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNKO2dCQUNqREUsUUFBUUs7WUFDVjtZQUVBLG1DQUFtQztZQUNuQyxJQUFJTixXQUFXO2dCQUNiQyxRQUFRO2dCQUNSLE1BQU1NLFdBQVd0QixPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ0g7Z0JBQ2xEQyxRQUFRTTtZQUNWO1lBRUEsT0FBT047UUFDVDtRQUVBLHNCQUFzQjtRQUN0QmQsS0FBSyxDQUFDLFlBQVksR0FBRyxDQUFDSTtZQUNwQixJQUFJQyxPQUFPRCxNQUFNRSxhQUFhLENBQUM7WUFDL0IsSUFBSSxDQUFDRCxRQUFRQSxLQUFLZ0IsSUFBSSxPQUFPLElBQUk7Z0JBQy9CaEIsT0FBTyxPQUEwQixPQUFuQmQ7WUFDaEI7WUFDQSxNQUFNK0IsZUFBZWxCLE1BQU1FLGFBQWEsQ0FBQyx5QkFBeUI7WUFDbEUsK0NBQStDO1lBQy9DLG9FQUFvRTtZQUVwRSx1QkFBdUI7WUFDdkIsTUFBTUssWUFBWVAsTUFBTUssbUJBQW1CLENBQUM7WUFDNUMsTUFBTWMsZUFBZW5CLE1BQU1LLG1CQUFtQixDQUFDO1lBQy9DLE1BQU1lLGtCQUFrQnBCLE1BQU1LLG1CQUFtQixDQUFDO1lBQ2xELE1BQU1nQixhQUFhckIsTUFBTUssbUJBQW1CLENBQUM7WUFDN0MsTUFBTUcsV0FBV1IsTUFBTUssbUJBQW1CLENBQUM7WUFDM0MsTUFBTUksWUFBWVQsTUFBTUssbUJBQW1CLENBQUM7WUFDNUMsTUFBTWlCLGNBQWN0QixNQUFNSyxtQkFBbUIsQ0FBQztZQUM5QyxNQUFNa0IsZUFBZXZCLE1BQU1LLG1CQUFtQixDQUFDO1lBRS9DLHdDQUF3QztZQUN4QyxJQUFJSyxPQUFPLEtBQVUsT0FBTFQsTUFBSztZQUVyQixnREFBZ0Q7WUFDaEQsTUFBTXVCLGNBQWN4QixNQUFNRSxhQUFhLENBQUMsdUJBQXVCO1lBQy9ELElBQUlzQixhQUFhO2dCQUNmZCxRQUFRLFNBQXFCLE9BQVpjLGFBQVk7WUFDL0I7WUFFQSxxREFBcUQ7WUFDckQsSUFBSWpCLFdBQVc7Z0JBQ2IsTUFBTWtCLFdBQVdsQixVQUFVTCxhQUFhLENBQUM7Z0JBQ3pDLElBQUl1QixVQUFVO29CQUNaZixRQUFRLGdCQUF5QixPQUFUZSxVQUFTO2dCQUNuQztZQUNGO1lBRUEsMENBQTBDO1lBQzFDLElBQUlQLGNBQWM7Z0JBQ2hCUixRQUFRLDBCQUF1QyxPQUFiUSxjQUFhO1lBQ2pEO1lBRUEsZ0NBQWdDO1lBQ2hDLElBQUlDLGNBQWM7Z0JBQ2hCVCxRQUFRO2dCQUNSLE1BQU1nQixjQUFjaEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNPO2dCQUNyRCx5Q0FBeUM7Z0JBQ3pDVCxRQUFRaUIsV0FBV0QsYUFBYTtZQUNsQztZQUVBLG1DQUFtQztZQUNuQyxJQUFJTixpQkFBaUI7Z0JBQ25CVixRQUFRO2dCQUNSLE1BQU1rQixpQkFBaUJsQyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ1E7Z0JBQ3hELHlDQUF5QztnQkFDekNWLFFBQVFpQixXQUFXQyxnQkFBZ0I7WUFDckM7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSVAsWUFBWTtnQkFDZFgsUUFBUTtnQkFDUixNQUFNbUIsWUFBWW5DLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDUztnQkFDbkQseUNBQXlDO2dCQUN6Q1gsUUFBUWlCLFdBQVdFLFdBQVc7WUFDaEM7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXJCLFVBQVU7Z0JBQ1pFLFFBQVE7Z0JBQ1IsTUFBTUssVUFBVXJCLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDSjtnQkFDakQseUNBQXlDO2dCQUN6Q0UsUUFBUWlCLFdBQVdaLFNBQVM7WUFDOUI7WUFFQSxtQ0FBbUM7WUFDbkMsSUFBSU4sV0FBVztnQkFDYkMsUUFBUTtnQkFDUixNQUFNTSxXQUFXdEIsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNIO2dCQUNsRCx5Q0FBeUM7Z0JBQ3pDQyxRQUFRaUIsV0FBV1gsVUFBVTtZQUMvQjtZQUVBLCtCQUErQjtZQUMvQixJQUFJTSxhQUFhO2dCQUNmLE1BQU1RLGFBQWFwQyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ1U7Z0JBQ3BEWixRQUFRLHlCQUEyQyxPQUFsQm9CLFdBQVdiLElBQUksSUFBRztZQUNyRDtZQUVBLGdDQUFnQztZQUNoQyxJQUFJTSxjQUFjO2dCQUNoQixNQUFNUSxjQUFjckMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNXO2dCQUNyRGIsUUFBUSxlQUEyQixPQUFacUIsYUFBWTtZQUNyQztZQUVBLDJCQUEyQjtZQUMzQixNQUFNQyxZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEsNEJBQTRCO1FBQzVCZCxLQUFLLENBQUMsa0JBQWtCLEdBQUcsQ0FBQ0k7WUFDMUIsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUNqRCxPQUFPLElBQVMsT0FBTEQsTUFBSztRQUNsQjtRQUVBLDBCQUEwQjtRQUMxQkwsS0FBSyxDQUFDLGdCQUFnQixHQUFHLENBQUNJO1lBQ3hCLElBQUlDLE9BQU9ELE1BQU1FLGFBQWEsQ0FBQztZQUMvQixJQUFJLENBQUNELFFBQVFBLEtBQUtnQixJQUFJLE9BQU8sSUFBSTtnQkFDL0JoQixPQUFPLFdBQThCLE9BQW5CZDtZQUNwQjtZQUVBLHVCQUF1QjtZQUN2QixNQUFNb0IsWUFBWVAsTUFBTUssbUJBQW1CLENBQUM7WUFDNUMsTUFBTThCLGFBQWFuQyxNQUFNSyxtQkFBbUIsQ0FBQztZQUM3QyxNQUFNa0IsZUFBZXZCLE1BQU1LLG1CQUFtQixDQUFDO1lBRS9DLHdDQUF3QztZQUN4QyxJQUFJSyxPQUFPLGlCQUFzQixPQUFMVCxNQUFLO1lBRWpDLDZCQUE2QjtZQUM3QixJQUFJTSxXQUFXO2dCQUNiLE1BQU1PLFdBQVdwQixPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ0w7Z0JBQ2xELE1BQU02QixZQUFZdEIsU0FBU0csSUFBSSxHQUFHb0IsT0FBTyxDQUFDLE1BQU0sSUFBSSxnQkFBZ0I7O2dCQUVwRSxvREFBb0Q7Z0JBQ3BELElBQUlELGNBQWMsS0FBSztvQkFDckIsa0NBQWtDO29CQUNsQzFCLFFBQVM7b0JBRVQsMERBQTBEO29CQUMxRCxJQUFJLENBQUN5QixZQUFZO3dCQUNmekIsUUFBUzt3QkFDVEEsUUFBUztvQkFDWCxPQUFPO3dCQUNMLGlIQUFpSDt3QkFDakgsTUFBTTRCLFlBQVk1QyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQzJDLHNCQUFzQixDQUFDSjt3QkFDOUR6QixRQUFRNEI7b0JBQ1Y7Z0JBQ0YsT0FFSyxJQUFJRixVQUFVSSxRQUFRLENBQUMsZUFBZUosVUFBVUksUUFBUSxDQUFDLE9BQU87b0JBQ25FLCtFQUErRTtvQkFDL0U5QixRQUFRLGlCQUEyQixPQUFWMEIsV0FBVTtvQkFFbkMsdURBQXVEO29CQUN2RCxJQUFJQSxVQUFVSSxRQUFRLENBQUMsbUJBQW1CLENBQUNMLFlBQVk7d0JBQ3JEekIsUUFBUzt3QkFDVEEsUUFBUztvQkFDWCxPQUFPLElBQUkwQixVQUFVSSxRQUFRLENBQUMsaUJBQWlCLENBQUNMLFlBQVk7d0JBQzFEekIsUUFBUzt3QkFDVEEsUUFBUztvQkFDWCxPQUFPLElBQUkwQixVQUFVSSxRQUFRLENBQUMsaUJBQWlCLENBQUNMLFlBQVk7d0JBQzFEekIsUUFBUzt3QkFDVEEsUUFBUzt3QkFDVEEsUUFBUztvQkFDWCxPQUFPLElBQUl5QixZQUFZO3dCQUNyQnpCLFFBQVM7d0JBQ1QsTUFBTTRCLFlBQVk1QyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ3VCO3dCQUNuRCx5Q0FBeUM7d0JBQ3pDekIsUUFBUWlCLFdBQVdXLFdBQVc7b0JBQ2hDO2dCQUNGLE9BQU87b0JBQ0wsc0NBQXNDO29CQUN0QyxJQUFJRyxVQUFVTDtvQkFFZCxpRUFBaUU7b0JBQ2pFLElBQUlELFlBQVk7d0JBQ2QsNkNBQTZDO3dCQUM3QyxNQUFNRyxZQUFZNUMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUM4Qyx3QkFBd0IsQ0FBQ1A7d0JBQ2hFTSxXQUFXLE1BQU1IO29CQUNuQjtvQkFFQSxzQkFBc0I7b0JBQ3RCNUIsUUFBUSxnQkFBd0IsT0FBUitCLFNBQVE7Z0JBQ2xDO1lBQ0Y7WUFFQSxnQ0FBZ0M7WUFDaEMsSUFBSWxCLGNBQWM7Z0JBQ2hCLE1BQU1RLGNBQWNyQyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ1c7Z0JBQ3JEYixRQUFRLG1CQUErQixPQUFacUIsYUFBWTtZQUN6QztZQUVBLCtCQUErQjtZQUMvQixNQUFNQyxZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEsZ0NBQWdDO1FBQ2hDZCxLQUFLLENBQUMsc0JBQXNCLEdBQUcsQ0FBQ0k7WUFDOUIsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUNqRCxPQUFPLElBQVMsT0FBTEQsTUFBSztRQUNsQjtRQUVBLDhCQUE4QjtRQUM5QkwsS0FBSyxDQUFDLG9CQUFvQixHQUFHLENBQUNJO1lBQzVCLE1BQU0yQyxNQUFNM0MsTUFBTUUsYUFBYSxDQUFDLGVBQWU7WUFDL0MsTUFBTTBDLFFBQVE1QyxNQUFNRSxhQUFhLENBQUMsaUJBQWlCO1lBRW5ELHdDQUF3QztZQUN4QyxJQUFJUSxPQUFPLEtBQWNrQyxPQUFURCxLQUFJLE9BQVcsT0FBTkMsT0FBTTtZQUUvQixtQ0FBbUM7WUFDbkMsTUFBTVosWUFBWWhDLE1BQU1pQyxZQUFZO1lBQ3BDLElBQUlELFdBQVc7Z0JBQ2IsTUFBTUUsV0FBV3hDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDb0I7Z0JBQ2xEdEIsUUFBUXdCO1lBQ1Y7WUFFQSxPQUFPeEI7UUFDVDtRQUVBLHVCQUF1QjtRQUN2QmQsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDSTtZQUNyQixNQUFNQyxPQUFPRCxNQUFNRSxhQUFhLENBQUMsZ0JBQWdCO1lBQ2pELE1BQU0yQyxVQUFVN0MsTUFBTUUsYUFBYSxDQUFDLG1CQUFtQjtZQUN2RCxNQUFNNEMsUUFBUTlDLE1BQU1FLGFBQWEsQ0FBQyxpQkFBaUI7WUFFbkQsd0NBQXdDO1lBQ3hDLElBQUlRLE9BQU87WUFFWCxtQ0FBbUM7WUFDbkMsSUFBSW1DLFlBQVkscUJBQXFCO2dCQUNuQ25DLFFBQVM7WUFDWCxPQUVLLElBQUltQyxTQUFTO2dCQUNoQm5DLFFBQVEsS0FBYSxPQUFSbUMsU0FBUTtnQkFDckJuQyxRQUFTO1lBQ1g7WUFFQSw0QkFBNEI7WUFDNUIsSUFBSW9DLE9BQU87Z0JBQ1RwQyxRQUFTO2dCQUNUQSxRQUFRLGdCQUFzQixPQUFOb0MsT0FBTTtZQUNoQztZQUVBcEMsUUFBUTtZQUVSLDRCQUE0QjtZQUM1QixNQUFNc0IsWUFBWWhDLE1BQU1pQyxZQUFZO1lBQ3BDLElBQUlELFdBQVc7Z0JBQ2IsTUFBTUUsV0FBV3hDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDb0I7Z0JBQ2xEdEIsUUFBUXdCO1lBQ1Y7WUFFQSxPQUFPeEI7UUFDVDtRQUVBLDJCQUEyQjtRQUMzQmQsS0FBSyxDQUFDLGlCQUFpQixHQUFHLENBQUNJO1lBQ3pCLE1BQU1DLE9BQU9ELE1BQU1FLGFBQWEsQ0FBQyxnQkFBZ0I7WUFFakQseUNBQXlDO1lBQ3pDLElBQUlRLE9BQU8saUJBQXNCLE9BQUxULE1BQUs7WUFFakMsZ0NBQWdDO1lBQ2hDLE1BQU0rQixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDZCxLQUFLLENBQUMsdUJBQXVCLEdBQUcsQ0FBQ0k7WUFDL0IsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUNqRCxPQUFPLElBQVMsT0FBTEQsTUFBSztRQUNsQjtRQUVBLDJCQUEyQjtRQUMzQkwsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDSTtZQUNyQixNQUFNQyxPQUFPRCxNQUFNRSxhQUFhLENBQUMsZ0JBQWdCO1lBRWpELHlDQUF5QztZQUN6QyxJQUFJUSxPQUFPLFdBQWdCLE9BQUxULE1BQUs7WUFFM0IsNEJBQTRCO1lBQzVCLE1BQU0rQixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEscUNBQXFDO1FBQ3JDZCxLQUFLLENBQUMsbUJBQW1CLEdBQUcsQ0FBQ0k7WUFDM0IsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUVqRCw2Q0FBNkM7WUFDN0MsSUFBSUQsU0FBUyxLQUFLO2dCQUNoQixPQUFRO1lBQ1Y7WUFFQSxvRkFBb0Y7WUFDcEYsSUFBSUEsS0FBSzhDLFVBQVUsQ0FBQyxlQUFlOUMsS0FBS3VDLFFBQVEsQ0FBQyxPQUFPO2dCQUN0RCxvRUFBb0U7Z0JBQ3BFLE9BQU8sSUFBUyxPQUFMdkMsTUFBSztZQUNsQjtZQUVBLE9BQU8sSUFBUyxPQUFMQSxNQUFLO1FBQ2xCO1FBRUEsNkJBQTZCO1FBQzdCTCxLQUFLLENBQUMsbUJBQW1CLEdBQUcsQ0FBQ0k7WUFDM0IsTUFBTWdELFlBQVloRCxNQUFNRSxhQUFhLENBQUMscUJBQXFCO1lBRTNELHVCQUF1QjtZQUN2QixNQUFNK0MsWUFBWWpELE1BQU1LLG1CQUFtQixDQUFDO1lBQzVDLE1BQU02QyxhQUFhbEQsTUFBTUssbUJBQW1CLENBQUM7WUFFN0MsaURBQWlEO1lBQ2pELElBQUlLLE9BQU87WUFFWCw2QkFBNkI7WUFDN0IsSUFBSXVDLFdBQVc7Z0JBQ2Isb0NBQW9DO2dCQUNwQyxNQUFNRSxXQUFXekQsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNxQztnQkFFbEQsaURBQWlEO2dCQUNqRCxNQUFNRyxRQUFRRCxTQUFTRSxLQUFLLENBQUM7Z0JBQzdCLElBQUlDLGdCQUFnQjtnQkFFcEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1JLE1BQU0sRUFBRUQsSUFBSztvQkFDckNELGlCQUFpQkYsS0FBSyxDQUFDRyxFQUFFLEdBQUc7b0JBRTVCLGtFQUFrRTtvQkFDbEUsSUFBSUgsS0FBSyxDQUFDRyxFQUFFLENBQUN0QyxJQUFJLEdBQUc4QixVQUFVLENBQUMsY0FBY1EsSUFBSSxJQUFJSCxNQUFNSSxNQUFNLEVBQUU7d0JBQ2pFLCtFQUErRTt3QkFDL0VGLGlCQUFpQixlQUF5QixPQUFWTixXQUFVO29CQUM1QztnQkFDRjtnQkFFQXRDLFFBQVE0QztZQUNWO1lBRUEsOEJBQThCO1lBQzlCLElBQUlKLFlBQVk7Z0JBQ2QsOERBQThEO2dCQUM5RCxNQUFNTyxvQkFBb0IsS0FBZSxPQUFWVCxXQUFVO2dCQUN6QyxNQUFNVSxZQUFZaEUsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNzQztnQkFFbkQsMERBQTBEO2dCQUMxRCxNQUFNRSxRQUFRTSxVQUFVTCxLQUFLLENBQUM7Z0JBQzlCLElBQUlDLGdCQUFnQjtnQkFFcEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1JLE1BQU0sRUFBRUQsSUFBSztvQkFDckNELGlCQUFpQkYsS0FBSyxDQUFDRyxFQUFFLEdBQUc7b0JBRTVCLDJFQUEyRTtvQkFDM0UsSUFBSUgsS0FBSyxDQUFDRyxFQUFFLENBQUN0QyxJQUFJLEdBQUc4QixVQUFVLENBQUMsY0FBY1EsSUFBSSxJQUFJSCxNQUFNSSxNQUFNLEVBQUU7d0JBQ2pFLHdGQUF3Rjt3QkFDeEZGLGlCQUFpQixlQUFpQyxPQUFsQkcsbUJBQWtCO29CQUNwRDtnQkFDRjtnQkFFQS9DLFFBQVE0QztZQUNWO1lBRUEsdUJBQXVCO1lBQ3ZCLE1BQU10QixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEscUJBQXFCO1FBQ3JCZCxLQUFLLENBQUMsV0FBVyxHQUFHLENBQUNJO1lBQ25CLHVCQUF1QjtZQUN2QixNQUFNbUIsZUFBZW5CLE1BQU1LLG1CQUFtQixDQUFDO1lBQy9DLE1BQU1lLGtCQUFrQnBCLE1BQU1LLG1CQUFtQixDQUFDO1lBRWxELGdCQUFnQjtZQUNoQixJQUFJSyxPQUFPO1lBRVgsZ0NBQWdDO1lBQ2hDLElBQUlTLGNBQWM7Z0JBQ2hCLE1BQU1PLGNBQWNoQyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ087Z0JBQ3JEVCxRQUFRZ0I7WUFDVjtZQUVBLG1DQUFtQztZQUNuQyxJQUFJTixpQkFBaUI7Z0JBQ25CLE1BQU1RLGlCQUFpQmxDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDUTtnQkFDeERWLFFBQVFrQjtZQUNWO1lBRUEsT0FBT2xCO1FBQ1Q7UUFFQSx1QkFBdUI7UUFDdkJkLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQ0k7WUFDckIsdUJBQXVCO1lBQ3ZCLE1BQU1tQixlQUFlbkIsTUFBTUssbUJBQW1CLENBQUM7WUFDL0MsTUFBTWUsa0JBQWtCcEIsTUFBTUssbUJBQW1CLENBQUM7WUFFbEQsZ0JBQWdCO1lBQ2hCLElBQUlLLE9BQU87WUFFWCxnQ0FBZ0M7WUFDaEMsSUFBSVMsY0FBYztnQkFDaEIsTUFBTU8sY0FBY2hDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDTztnQkFDckRULFFBQVFnQjtZQUNWO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlOLGlCQUFpQjtnQkFDbkIsTUFBTVEsaUJBQWlCbEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNRO2dCQUN4RFYsUUFBUWtCO1lBQ1Y7WUFFQSxPQUFPbEI7UUFDVDtRQUVBLDRCQUE0QjtRQUM1QmQsS0FBSyxDQUFDLGtCQUFrQixHQUFHLENBQUNJO1lBQzFCLE1BQU0yRCxZQUFZM0QsTUFBTUUsYUFBYSxDQUFDLHFCQUFxQjtZQUUzRCx1QkFBdUI7WUFDdkIsTUFBTTBELGNBQWM1RCxNQUFNNkQsU0FBUztZQUVuQyx5REFBeUQ7WUFDekQsSUFBSUMsaUJBQWlCO1lBQ3JCLElBQUlDLG1CQUFtQjtZQUV2QixJQUFJSCxlQUFlQSxZQUFZSSxJQUFJLEtBQUssaUJBQWlCO2dCQUN2RCxNQUFNekQsWUFBWXFELFlBQVl2RCxtQkFBbUIsQ0FBQztnQkFDbEQsSUFBSUUsYUFBYUEsVUFBVXlELElBQUksS0FBSyxvQkFBb0I7b0JBQ3RELE1BQU12QyxXQUFXbEIsVUFBVUwsYUFBYSxDQUFDO29CQUN6QzRELGlCQUFpQnJDLGFBQWE7b0JBQzlCc0MsbUJBQW1CdEMsYUFBYSxPQUFPLENBQUNBLFNBQVNlLFFBQVEsQ0FBQyxlQUFlLENBQUNmLFNBQVNlLFFBQVEsQ0FBQztnQkFDOUY7WUFDRjtZQUVBLHdEQUF3RDtZQUN4RCxJQUFJOUI7WUFDSixJQUFJb0QsZ0JBQWdCO2dCQUNsQixpRUFBaUU7Z0JBQ2pFcEQsT0FBTyxhQUF1QixPQUFWaUQsV0FBVTtZQUNoQyxPQUFPLElBQUlJLGtCQUFrQjtnQkFDM0IsNERBQTREO2dCQUM1RHJELE9BQU8sR0FBYSxPQUFWaUQ7WUFDWixPQUFPO2dCQUNMLGdEQUFnRDtnQkFDaERqRCxPQUFPLGFBQXVCLE9BQVZpRCxXQUFVO1lBQ2hDO1lBRUEsaUNBQWlDO1lBQ2pDLE1BQU0zQixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEsNERBQTREO1FBQzVEZCxNQUFNMkMsc0JBQXNCLEdBQUcsQ0FBQ0o7WUFDOUIsSUFBSSxDQUFDQSxZQUFZO2dCQUNmLE9BQU87WUFDVDtZQUVBLHdDQUF3QztZQUN4QyxNQUFNRyxZQUFZNUMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUN1QjtZQUVuRCxpREFBaUQ7WUFDakQsTUFBTThCLGFBQWEzQixVQUFVZSxLQUFLLENBQUM7WUFDbkMsSUFBSWEsaUJBQWlCO1lBRXJCLEtBQUssTUFBTUMsUUFBUUYsV0FBWTtnQkFDN0IsSUFBSUUsS0FBS2xELElBQUksSUFBSTtvQkFDZiwrRUFBK0U7b0JBQy9FaUQsa0JBQWtCLGFBQXlCLE9BQVpDLEtBQUtsRCxJQUFJLElBQUc7Z0JBQzdDO1lBQ0Y7WUFFQSxPQUFPaUQ7UUFDVDtRQUVBLDhEQUE4RDtRQUM5RHRFLE1BQU04Qyx3QkFBd0IsR0FBRyxDQUFDUDtZQUNoQyxJQUFJLENBQUNBLFlBQVk7Z0JBQ2YsT0FBTztZQUNUO1lBRUEsd0NBQXdDO1lBQ3hDLE1BQU1HLFlBQVk1QyxPQUFPQyxPQUFPLENBQUNDLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQ3VCO1lBRW5ELGdEQUFnRDtZQUNoRCxNQUFNaUMsU0FBUzlCLFVBQ1pyQixJQUFJLEdBQ0pvQyxLQUFLLENBQUMsTUFDTmdCLE1BQU0sQ0FBQyxDQUFDRixPQUFTQSxLQUFLbEQsSUFBSSxJQUMxQnFELEdBQUcsQ0FBQyxDQUFDSCxPQUFTQSxLQUFLbEQsSUFBSSxJQUN2QnNELElBQUksQ0FBQztZQUVSLE9BQU9IO1FBQ1Q7UUFFQSw2QkFBNkI7UUFDN0J4RSxLQUFLLENBQUMsbUJBQW1CLEdBQUcsQ0FBQ0k7WUFDM0IsTUFBTTJDLE1BQU0zQyxNQUFNRSxhQUFhLENBQUMsZUFBZTtZQUMvQyxNQUFNMEMsUUFBUTVDLE1BQU1FLGFBQWEsQ0FBQyxpQkFBaUI7WUFFbkQsd0NBQXdDO1lBQ3hDLElBQUlRLE9BQU8sS0FBYWtDLE9BQVJELEtBQUksTUFBVSxPQUFOQyxPQUFNO1lBRTlCLGtDQUFrQztZQUNsQyxNQUFNWixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRd0I7WUFDVjtZQUVBLE9BQU94QjtRQUNUO1FBRUEsaUNBQWlDO1FBQ2pDZCxLQUFLLENBQUMsdUJBQXVCLEdBQUcsQ0FBQ0k7WUFDL0IsTUFBTUMsT0FBT0QsTUFBTUUsYUFBYSxDQUFDLGdCQUFnQjtZQUVqRCxrQ0FBa0M7WUFDbEMsSUFBSVEsT0FBTyxJQUFTLE9BQUxULE1BQUs7WUFFcEIsa0NBQWtDO1lBQ2xDLE1BQU0rQixZQUFZaEMsTUFBTWlDLFlBQVk7WUFDcEMsSUFBSUQsV0FBVztnQkFDYixNQUFNRSxXQUFXeEMsT0FBT0MsT0FBTyxDQUFDQyxLQUFLLENBQUNnQixXQUFXLENBQUNvQjtnQkFDbER0QixRQUFRLEtBQWMsT0FBVHdCO1lBQ2Y7WUFFQSxPQUFPeEI7UUFDVDtRQUVBLHFDQUFxQztRQUNyQ2QsS0FBSyxDQUFDLDJCQUEyQixHQUFHLENBQUNJO1lBQ25DLE1BQU1DLE9BQU9ELE1BQU1FLGFBQWEsQ0FBQyxnQkFBZ0I7WUFFakQsc0NBQXNDO1lBQ3RDLElBQUlRLE9BQU8sSUFBUyxPQUFMVCxNQUFLO1lBRXBCLGtDQUFrQztZQUNsQyxNQUFNK0IsWUFBWWhDLE1BQU1pQyxZQUFZO1lBQ3BDLElBQUlELFdBQVc7Z0JBQ2IsTUFBTUUsV0FBV3hDLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDb0I7Z0JBQ2xEdEIsUUFBUSxLQUFjLE9BQVR3QjtZQUNmO1lBRUEsT0FBT3hCO1FBQ1Q7UUFFQSxpREFBaUQ7UUFDakRkLE1BQU1nQixXQUFXLEdBQUcsQ0FBQ1o7WUFDbkIsSUFBSSxDQUFDQSxPQUFPO2dCQUNWLE9BQU87WUFDVDtZQUVBLG1EQUFtRDtZQUNuRCxJQUFJSixLQUFLLENBQUNJLE1BQU1nRSxJQUFJLENBQUMsRUFBRTtnQkFDckIsT0FBT3BFLEtBQUssQ0FBQ0ksTUFBTWdFLElBQUksQ0FBQyxDQUFDaEU7WUFDM0I7WUFFQSx3Q0FBd0M7WUFDeENGLFFBQVEwRSxJQUFJLENBQUMsc0NBQWlELE9BQVh4RSxNQUFNZ0UsSUFBSTtZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxPQUFPUyxhQUFhQyxTQUFjLEVBQVU7UUFDMUMsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ2pGLElBQUk7UUFFVCwyQkFBMkI7UUFDM0IsTUFBTWtGLFlBQVlELFVBQVVFLFlBQVksQ0FBQztRQUV6Qyx5Q0FBeUM7UUFDekMsSUFBSWxFLE9BQU87UUFDWEEsUUFBUTtRQUVSLEtBQUssTUFBTVYsU0FBUzJFLFVBQVc7WUFDN0IsSUFBSWpGLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDSSxNQUFNZ0UsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BDdEQsUUFBUWhCLE9BQU9DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDZ0IsV0FBVyxDQUFDWjtZQUMzQztRQUNGO1FBRUEsT0FBT1U7SUFDVDtBQUNGO0FBRUEsaUNBQWlDO0FBQ2pDLFNBQVNpQixXQUFXakIsSUFBWSxFQUFFbUUsV0FBbUI7SUFDbkQsTUFBTUMsU0FBUyxLQUFLQyxNQUFNLENBQUNGO0lBQzNCLE9BQU9uRSxLQUNKMkMsS0FBSyxDQUFDLE1BQ05pQixHQUFHLENBQUMsQ0FBQ0g7UUFDSixJQUFJQSxLQUFLbEQsSUFBSSxPQUFPLElBQUksT0FBT2tEO1FBQy9CLE9BQU9XLFNBQVNYO0lBQ2xCLEdBQ0NJLElBQUksQ0FBQztBQUNWIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh1Z29hXFxEZXNrdG9wXFxyZXBvc1xccmVwb3NcXG1ldGFtb2RlbDJibG9ja2x5XFxnZW5lcmF0ZWRcXGJvd2xpbmdfYWxsZXktdmlzdWFsY2lcXGJsb2NrbHktY29kZS1nZW5lcmF0b3IudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGUgZ2VuZXJhdG9yIGZvciBFY29yZSBibG9ja3Ncbi8vIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29kZSBnZW5lcmF0b3IgZm9yIHRoZSBFY29yZSBibG9ja3NcblxubGV0IGdlbmVyYXRvckluaXRpYWxpemVkID0gZmFsc2VcblxuLy8gQWRkIHRoaXMgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZSwgYWZ0ZXIgdGhlIGdlbmVyYXRvckluaXRpYWxpemVkIHZhcmlhYmxlXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKCk6IHN0cmluZyB7XG4gIHJldHVybiBNYXRoLmZsb29yKDEwMDAwICsgTWF0aC5yYW5kb20oKSAqIDkwMDAwKS50b1N0cmluZygpXG59XG5cbmV4cG9ydCBjbGFzcyBFY29yZUdlbmVyYXRvciB7XG4gIC8vIEluaXRpYWxpemUgdGhlIGdlbmVyYXRvclxuICBzdGF0aWMgaW5pdCgpIHtcbiAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGluaXRpYWxpemF0aW9uc1xuICAgIGlmIChnZW5lcmF0b3JJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmFtZXNwYWNlIGZvciBvdXIgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICAgIGlmICghd2luZG93LkJsb2NrbHkuRWNvcmUpIHtcbiAgICAgIHdpbmRvdy5CbG9ja2x5LkVjb3JlID0ge31cbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgZ2VuZXJhdG9yIGZ1bmN0aW9ucyBmb3IgZWFjaCBibG9jayB0eXBlXG4gICAgdGhpcy5kZWZpbmVHZW5lcmF0b3JzKClcblxuICAgIC8vIE1hcmsgYXMgaW5pdGlhbGl6ZWRcbiAgICBnZW5lcmF0b3JJbml0aWFsaXplZCA9IHRydWVcbiAgICBjb25zb2xlLmxvZyhcIkVjb3JlIGdlbmVyYXRvciBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcIilcbiAgfVxuXG4gIC8vIERlZmluZSBnZW5lcmF0b3IgZnVuY3Rpb25zIGZvciBhbGwgYmxvY2sgdHlwZXNcbiAgc3RhdGljIGRlZmluZUdlbmVyYXRvcnMoKSB7XG4gICAgY29uc3QgRWNvcmUgPSB3aW5kb3cuQmxvY2tseS5FY29yZVxuXG4gICAgLy8gUGlwZWxpbmUgYmxvY2sgZ2VuZXJhdG9yXG4gICAgRWNvcmVbXCJlY29yZV9waXBlbGluZVwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKSB8fCBcImRlZmF1bHRfcGlwZWxpbmVcIlxuICAgICAgY29uc3QgY29uY3VycmVudCA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX0NPTkNVUlJFTlRcIikgPT09IFwiVFJVRVwiXG5cbiAgICAgIC8vIEdldCBjb25uZWN0ZWQgYmxvY2tzXG4gICAgICBjb25zdCB3aGVuQmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9XSEVOXCIpXG4gICAgICBjb25zdCBqb2JCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0pPQlwiKVxuICAgICAgY29uc3QgdG9vbEJsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfVE9PTFwiKVxuICAgICAgY29uc3QgZW52QmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9FTlZJUk9OTUVOVFwiKVxuICAgICAgY29uc3QgcGVybUJsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfUEVSTUlTU0lPTlwiKVxuXG4gICAgICAvLyBHZW5lcmF0ZSBjb2RlIHdpdGggcHJvcGVyIGluZGVudGF0aW9uXG4gICAgICBsZXQgY29kZSA9IGAjIFBpcGVsaW5lOiAke25hbWV9XFxuYFxuICAgICAgY29kZSArPSBgbmFtZTogJHtuYW1lfVxcbmBcbiAgICAgIC8vIE9ubHkgaW5jbHVkZSBjb25jdXJyZW50IGlmIGl0J3MgdHJ1ZVxuICAgICAgaWYgKGNvbmN1cnJlbnQpIHtcbiAgICAgICAgY29kZSArPSBgY29uY3VycmVudDogJHtjb25jdXJyZW50fVxcbmBcbiAgICAgIH1cblxuICAgICAgY29kZSArPSBgXFxuYFxuXG4gICAgICAvLyBBZGQgd2hlbiBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgaWYgKHdoZW5CbG9jaykge1xuICAgICAgICBjb25zdCB3aGVuQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKHdoZW5CbG9jaylcbiAgICAgICAgY29kZSArPSB3aGVuQ29kZVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgam9iIGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoam9iQmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcImpvYnM6XFxuXCJcbiAgICAgICAgY29uc3Qgam9iQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGpvYkJsb2NrKVxuICAgICAgICBjb2RlICs9IGpvYkNvZGVcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRvb2wgYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmICh0b29sQmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcInRvb2xzOlxcblwiXG4gICAgICAgIGNvbnN0IHRvb2xDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUodG9vbEJsb2NrKVxuICAgICAgICBjb2RlICs9IHRvb2xDb2RlXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBlbnZpcm9ubWVudCBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgaWYgKGVudkJsb2NrKSB7XG4gICAgICAgIGNvZGUgKz0gXCJlbnY6XFxuXCJcbiAgICAgICAgY29uc3QgZW52Q29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGVudkJsb2NrKVxuICAgICAgICBjb2RlICs9IGVudkNvZGVcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHBlcm1pc3Npb24gYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmIChwZXJtQmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcInBlcm1pc3Npb25zOlxcblwiXG4gICAgICAgIGNvbnN0IHBlcm1Db2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUocGVybUJsb2NrKVxuICAgICAgICBjb2RlICs9IHBlcm1Db2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gSm9iIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfam9iXCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGxldCBuYW1lID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKVxuICAgICAgaWYgKCFuYW1lIHx8IG5hbWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIG5hbWUgPSBgam9iXyR7Z2VuZXJhdGVSYW5kb21JZCgpfWBcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsbG93RmFpbHVyZSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX0FMTE9XRkFJTFVSRVwiKSA9PT0gXCJUUlVFXCJcbiAgICAgIC8vIFdlJ3JlIG5vdCB1c2luZyB0aGUgZGVzY3JpcHRpb24gYXMgcmVxdWVzdGVkXG4gICAgICAvLyBjb25zdCBkZXNjcmlwdGlvbiA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX0RFU0NSSVBUSU9OXCIpIHx8IFwiXCJcblxuICAgICAgLy8gR2V0IGNvbm5lY3RlZCBibG9ja3NcbiAgICAgIGNvbnN0IHRvb2xCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX1RPT0xcIilcbiAgICAgIGNvbnN0IGNvbW1hbmRCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0NPTU1BTkRcIilcbiAgICAgIGNvbnN0IGlmVGhlbkVsc2VCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0lGVEhFTkVMU0VcIilcbiAgICAgIGNvbnN0IGlucHV0QmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9JTlBVVFwiKVxuICAgICAgY29uc3QgZW52QmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9FTlZJUk9OTUVOVFwiKVxuICAgICAgY29uc3QgcGVybUJsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfUEVSTUlTU0lPTlwiKVxuICAgICAgY29uc3Qgb3V0cHV0QmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiUkVMX09VVFBVVFwiKVxuICAgICAgY29uc3QgZGVwZW5kc0Jsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIlJFTF9ERVBFTkRTXCIpXG5cbiAgICAgIC8vIEdlbmVyYXRlIGNvZGUgd2l0aCBwcm9wZXIgaW5kZW50YXRpb25cbiAgICAgIGxldCBjb2RlID0gYCAgJHtuYW1lfTpcXG5gXG5cbiAgICAgIC8vIEluY2x1ZGUgZGVzY3JpcHRpb24gYXMgYSBjb21tZW50IGlmIGl0IGV4aXN0c1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9ERVNDUklQVElPTlwiKSB8fCBcIlwiXG4gICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29kZSArPSBgICAgICMgJHtkZXNjcmlwdGlvbn1cXG5gXG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGUgdG9vbCBuYW1lIGZvciBydW5zLW9uIGlmIGEgdG9vbCBpcyBwcmVzZW50XG4gICAgICBpZiAodG9vbEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdG9vbEJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX05BTUVcIilcbiAgICAgICAgaWYgKHRvb2xOYW1lKSB7XG4gICAgICAgICAgY29kZSArPSBgICAgIHJ1bnMtb246ICR7dG9vbE5hbWV9XFxuYFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgYWRkIGNvbnRpbnVlLW9uLWVycm9yIGlmIGl0J3MgdHJ1ZVxuICAgICAgaWYgKGFsbG93RmFpbHVyZSkge1xuICAgICAgICBjb2RlICs9IGAgICAgY29udGludWUtb24tZXJyb3I6ICR7YWxsb3dGYWlsdXJlfVxcbmBcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNvbW1hbmQgYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmIChjb21tYW5kQmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcIiAgICBzdGVwczpcXG5cIlxuICAgICAgICBjb25zdCBjb21tYW5kQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGNvbW1hbmRCbG9jaylcbiAgICAgICAgLy8gSW5jcmVhc2UgaW5kZW50YXRpb24gZm9yIG5lc3RlZCBibG9ja3NcbiAgICAgICAgY29kZSArPSBpbmRlbnRDb2RlKGNvbW1hbmRDb2RlLCAzKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgaWZUaGVuRWxzZSBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgaWYgKGlmVGhlbkVsc2VCbG9jaykge1xuICAgICAgICBjb2RlICs9IFwiICAgIGlmOlxcblwiXG4gICAgICAgIGNvbnN0IGlmVGhlbkVsc2VDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoaWZUaGVuRWxzZUJsb2NrKVxuICAgICAgICAvLyBJbmNyZWFzZSBpbmRlbnRhdGlvbiBmb3IgbmVzdGVkIGJsb2Nrc1xuICAgICAgICBjb2RlICs9IGluZGVudENvZGUoaWZUaGVuRWxzZUNvZGUsIDMpXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBpbnB1dCBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgaWYgKGlucHV0QmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcIiAgICBpbnB1dHM6XFxuXCJcbiAgICAgICAgY29uc3QgaW5wdXRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoaW5wdXRCbG9jaylcbiAgICAgICAgLy8gSW5jcmVhc2UgaW5kZW50YXRpb24gZm9yIG5lc3RlZCBibG9ja3NcbiAgICAgICAgY29kZSArPSBpbmRlbnRDb2RlKGlucHV0Q29kZSwgMylcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGVudmlyb25tZW50IGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoZW52QmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcIiAgICBlbnY6XFxuXCJcbiAgICAgICAgY29uc3QgZW52Q29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGVudkJsb2NrKVxuICAgICAgICAvLyBJbmNyZWFzZSBpbmRlbnRhdGlvbiBmb3IgbmVzdGVkIGJsb2Nrc1xuICAgICAgICBjb2RlICs9IGluZGVudENvZGUoZW52Q29kZSwgMylcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHBlcm1pc3Npb24gYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmIChwZXJtQmxvY2spIHtcbiAgICAgICAgY29kZSArPSBcIiAgICBwZXJtaXNzaW9uczpcXG5cIlxuICAgICAgICBjb25zdCBwZXJtQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKHBlcm1CbG9jaylcbiAgICAgICAgLy8gSW5jcmVhc2UgaW5kZW50YXRpb24gZm9yIG5lc3RlZCBibG9ja3NcbiAgICAgICAgY29kZSArPSBpbmRlbnRDb2RlKHBlcm1Db2RlLCAzKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgb3V0cHV0IGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAob3V0cHV0QmxvY2spIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0Q29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKG91dHB1dEJsb2NrKVxuICAgICAgICBjb2RlICs9IGAgICAgb3V0cHV0czpcXG4gICAgICAtICR7b3V0cHV0Q29kZS50cmltKCl9XFxuYFxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZGVwZW5kcyBibG9ja3MgaWYgcHJlc2VudFxuICAgICAgaWYgKGRlcGVuZHNCbG9jaykge1xuICAgICAgICBjb25zdCBkZXBlbmRzQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGRlcGVuZHNCbG9jaylcbiAgICAgICAgY29kZSArPSBgICAgIG5lZWRzOiBbJHtkZXBlbmRzQ29kZX1dXFxuYFxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbmV4dCBqb2IgYmxvY2tcbiAgICAgIGNvbnN0IG5leHRCbG9jayA9IGJsb2NrLmdldE5leHRCbG9jaygpXG4gICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUobmV4dEJsb2NrKVxuICAgICAgICBjb2RlICs9IG5leHRDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gSm9iIHZhbHVlIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfam9iX3ZhbHVlXCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9OQU1FXCIpIHx8IFwidW5uYW1lZF9qb2JcIlxuICAgICAgcmV0dXJuIGBcIiR7bmFtZX1cImBcbiAgICB9XG5cbiAgICAvLyBDb21tYW5kIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfY29tbWFuZFwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBsZXQgbmFtZSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX05BTUVcIilcbiAgICAgIGlmICghbmFtZSB8fCBuYW1lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBuYW1lID0gYGNvbW1hbmRfJHtnZW5lcmF0ZVJhbmRvbUlkKCl9YFxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgY29ubmVjdGVkIGJsb2Nrc1xuICAgICAgY29uc3QgdG9vbEJsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfVE9PTFwiKVxuICAgICAgY29uc3QgcGFyYW1CbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX1BBUkFNRVRFUlwiKVxuICAgICAgY29uc3QgZGVwZW5kc0Jsb2NrID0gYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIlJFTF9ERVBFTkRTXCIpXG5cbiAgICAgIC8vIEdlbmVyYXRlIGNvZGUgd2l0aCBwcm9wZXIgaW5kZW50YXRpb25cbiAgICAgIGxldCBjb2RlID0gYCAgICAgIC0gbmFtZTogJHtuYW1lfVxcbmBcblxuICAgICAgLy8gQWRkIHRvb2wgYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmICh0b29sQmxvY2spIHtcbiAgICAgICAgY29uc3QgdG9vbENvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZSh0b29sQmxvY2spXG4gICAgICAgIGNvbnN0IHRvb2xWYWx1ZSA9IHRvb2xDb2RlLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCBcIlwiKSAvLyBSZW1vdmUgcXVvdGVzXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHNoZWxsIGNvbW1hbmQgKGRlbm90ZWQgYnkgXCJ8XCIpXG4gICAgICAgIGlmICh0b29sVmFsdWUgPT09IFwifFwiKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHNoZWxsIGNvbW1hbmQgdXNpbmcgfFxuICAgICAgICAgIGNvZGUgKz0gYCAgICAgICAgcnVuOiB8XFxuYFxuXG4gICAgICAgICAgLy8gQWRkIGRlZmF1bHQgc2hlbGwgY29tbWFuZCBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZFxuICAgICAgICAgIGlmICghcGFyYW1CbG9jaykge1xuICAgICAgICAgICAgY29kZSArPSBgICAgICAgICAgIGVjaG8gXCJSdW5uaW5nIHNoZWxsIGNvbW1hbmRzXCJcXG5gXG4gICAgICAgICAgICBjb2RlICs9IGAgICAgICAgICAgZWNobyBcIkN1cnJlbnQgZGlyZWN0b3J5OiAkKHB3ZClcIlxcbmBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHNoZWxsIGNvbW1hbmRzIHdpdGggcGFyYW1ldGVycywgd2UgbmVlZCB0byBlbnN1cmUgZWFjaCBwYXJhbWV0ZXIgaXMgb24gYSBuZXcgbGluZSB3aXRoIGNvcnJlY3QgaW5kZW50YXRpb25cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLnByb2Nlc3NTaGVsbFBhcmFtZXRlcnMocGFyYW1CbG9jaylcbiAgICAgICAgICAgIGNvZGUgKz0gcGFyYW1Db2RlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0b29sIGNvbnRhaW5zIFwiYWN0aW9ucy9cIiBvciBcIkB2XCIgaW4gaXRzIHZhbHVlIC0gYm90aCBzaG91bGQgYmUgdHJlYXRlZCBhcyBHaXRIdWIgQWN0aW9uc1xuICAgICAgICBlbHNlIGlmICh0b29sVmFsdWUuaW5jbHVkZXMoXCJhY3Rpb25zL1wiKSB8fCB0b29sVmFsdWUuaW5jbHVkZXMoXCJAdlwiKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBHaXRIdWIgQWN0aW9ucyB0b29sIC0gdXNlIHRoZSBleGFjdCB0b29sVmFsdWUgd2l0aG91dCBtb2RpZmljYXRpb25cbiAgICAgICAgICBjb2RlICs9IGAgICAgICAgIHVzZXM6ICR7dG9vbFZhbHVlfVxcbmBcblxuICAgICAgICAgIC8vIEFkZCBhcHByb3ByaWF0ZSBkZWZhdWx0IHBhcmFtZXRlcnMgYmFzZWQgb24gdGhlIHRvb2xcbiAgICAgICAgICBpZiAodG9vbFZhbHVlLmluY2x1ZGVzKFwic2V0dXAtcHl0aG9uXCIpICYmICFwYXJhbUJsb2NrKSB7XG4gICAgICAgICAgICBjb2RlICs9IGAgICAgICAgIHdpdGg6XFxuYFxuICAgICAgICAgICAgY29kZSArPSBgICAgICAgICAgIHB5dGhvbi12ZXJzaW9uOiAnMy54JyAgIyBVc2VzIHRoZSBsYXRlc3Qgc3RhYmxlIDMueCB2ZXJzaW9uXFxuYFxuICAgICAgICAgIH0gZWxzZSBpZiAodG9vbFZhbHVlLmluY2x1ZGVzKFwic2V0dXAtbm9kZVwiKSAmJiAhcGFyYW1CbG9jaykge1xuICAgICAgICAgICAgY29kZSArPSBgICAgICAgICB3aXRoOlxcbmBcbiAgICAgICAgICAgIGNvZGUgKz0gYCAgICAgICAgICBub2RlLXZlcnNpb246ICcxOC54J1xcbmBcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvb2xWYWx1ZS5pbmNsdWRlcyhcInNldHVwLWphdmFcIikgJiYgIXBhcmFtQmxvY2spIHtcbiAgICAgICAgICAgIGNvZGUgKz0gYCAgICAgICAgd2l0aDpcXG5gXG4gICAgICAgICAgICBjb2RlICs9IGAgICAgICAgICAgZGlzdHJpYnV0aW9uOiAndGVtdXJpbidcXG5gXG4gICAgICAgICAgICBjb2RlICs9IGAgICAgICAgICAgamF2YS12ZXJzaW9uOiAnMTcnXFxuYFxuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1CbG9jaykge1xuICAgICAgICAgICAgY29kZSArPSBgICAgICAgICB3aXRoOlxcbmBcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKHBhcmFtQmxvY2spXG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBpbmRlbnRhdGlvbiBmb3IgbmVzdGVkIGJsb2Nrc1xuICAgICAgICAgICAgY29kZSArPSBpbmRlbnRDb2RlKHBhcmFtQ29kZSwgNClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVndWxhciB0b29sIC0gbGlrZSB5YXJuLCBucG0sIGV0Yy5cbiAgICAgICAgICBsZXQgY29tbWFuZCA9IHRvb2xWYWx1ZVxuXG4gICAgICAgICAgLy8gQWRkIHBhcmFtZXRlcnMgaW4gYSBzaW5nbGUgbGluZSB3aXRoIHNpbmdsZSBzcGFjZSBiZXR3ZWVuIHRoZW1cbiAgICAgICAgICBpZiAocGFyYW1CbG9jaykge1xuICAgICAgICAgICAgLy8gR2V0IHBhcmFtZXRlcnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBjb21tYW5kXG4gICAgICAgICAgICBjb25zdCBwYXJhbUNvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5wcm9jZXNzUmVndWxhclBhcmFtZXRlcnMocGFyYW1CbG9jaylcbiAgICAgICAgICAgIGNvbW1hbmQgKz0gXCIgXCIgKyBwYXJhbUNvZGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGQgdGhlIHJ1biBjb21tYW5kXG4gICAgICAgICAgY29kZSArPSBgICAgICAgICBydW46ICR7Y29tbWFuZH1cXG5gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGRlcGVuZHMgYmxvY2tzIGlmIHByZXNlbnRcbiAgICAgIGlmIChkZXBlbmRzQmxvY2spIHtcbiAgICAgICAgY29uc3QgZGVwZW5kc0NvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShkZXBlbmRzQmxvY2spXG4gICAgICAgIGNvZGUgKz0gYCAgICAgICAgbmVlZHM6IFske2RlcGVuZHNDb2RlfV1cXG5gXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBuZXh0IGNvbW1hbmQgYmxvY2tcbiAgICAgIGNvbnN0IG5leHRCbG9jayA9IGJsb2NrLmdldE5leHRCbG9jaygpXG4gICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUobmV4dEJsb2NrKVxuICAgICAgICBjb2RlICs9IG5leHRDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gQ29tbWFuZCB2YWx1ZSBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX2NvbW1hbmRfdmFsdWVcIl0gPSAoYmxvY2s6IGFueSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX05BTUVcIikgfHwgXCJ1bm5hbWVkX2NvbW1hbmRcIlxuICAgICAgcmV0dXJuIGBcIiR7bmFtZX1cImBcbiAgICB9XG5cbiAgICAvLyBFbnZpcm9ubWVudCBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX2Vudmlyb25tZW50XCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX0tFWVwiKSB8fCBcIkVOVl9LRVlcIlxuICAgICAgY29uc3QgdmFsdWUgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9WQUxVRVwiKSB8fCBcInZhbHVlXCJcblxuICAgICAgLy8gR2VuZXJhdGUgY29kZSB3aXRoIHByb3BlciBpbmRlbnRhdGlvblxuICAgICAgbGV0IGNvZGUgPSBgICAke2tleX06IFwiJHt2YWx1ZX1cIlxcbmBcblxuICAgICAgLy8gQ2hlY2sgZm9yIG5leHQgZW52aXJvbm1lbnQgYmxvY2tcbiAgICAgIGNvbnN0IG5leHRCbG9jayA9IGJsb2NrLmdldE5leHRCbG9jaygpXG4gICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUobmV4dEJsb2NrKVxuICAgICAgICBjb2RlICs9IG5leHRDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gV2hlbiBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX3doZW5cIl0gPSAoYmxvY2s6IGFueSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX05BTUVcIikgfHwgXCJ1bm5hbWVkX3RyaWdnZXJcIlxuICAgICAgY29uc3QgdHJpZ2dlciA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX1RSSUdHRVJcIikgfHwgXCJcIlxuICAgICAgY29uc3QgdGltZXIgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9USU1FUlwiKSB8fCBcIlwiXG5cbiAgICAgIC8vIEdlbmVyYXRlIGNvZGUgd2l0aCBwcm9wZXIgaW5kZW50YXRpb25cbiAgICAgIGxldCBjb2RlID0gXCJvbjpcXG5cIlxuXG4gICAgICAvLyBIYW5kbGUgd29ya2Zsb3dfZGlzcGF0Y2ggdHJpZ2dlclxuICAgICAgaWYgKHRyaWdnZXIgPT09IFwid29ya2Zsb3dfZGlzcGF0Y2hcIikge1xuICAgICAgICBjb2RlICs9IGAgIHdvcmtmbG93X2Rpc3BhdGNoOlxcbmBcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBvdGhlciB0cmlnZ2VycyB3aXRoIGJyYW5jaGVzXG4gICAgICBlbHNlIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgIGNvZGUgKz0gYCAgJHt0cmlnZ2VyfTpcXG5gXG4gICAgICAgIGNvZGUgKz0gYCAgICBicmFuY2hlczogW21haW5dXFxuYFxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgc2NoZWR1bGVkIHRyaWdnZXJzXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY29kZSArPSBgICBzY2hlZHVsZTpcXG5gXG4gICAgICAgIGNvZGUgKz0gYCAgICAtIGNyb246IFwiJHt0aW1lcn1cIlxcbmBcbiAgICAgIH1cblxuICAgICAgY29kZSArPSBcIlxcblwiXG5cbiAgICAgIC8vIENoZWNrIGZvciBuZXh0IHdoZW4gYmxvY2tcbiAgICAgIGNvbnN0IG5leHRCbG9jayA9IGJsb2NrLmdldE5leHRCbG9jaygpXG4gICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUobmV4dEJsb2NrKVxuICAgICAgICBjb2RlICs9IG5leHRDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gQXJ0aWZhY3QgYmxvY2sgZ2VuZXJhdG9yXG4gICAgRWNvcmVbXCJlY29yZV9hcnRpZmFjdFwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKSB8fCBcInVubmFtZWRfYXJ0aWZhY3RcIlxuXG4gICAgICAvLyBGb3Igc3RhdGVtZW50IGJsb2NrcywgcmV0dXJuIGZ1bGwgY29kZVxuICAgICAgbGV0IGNvZGUgPSBgICAgICAgLSBuYW1lOiAke25hbWV9XFxuYFxuXG4gICAgICAvLyBDaGVjayBmb3IgbmV4dCBhcnRpZmFjdCBibG9ja1xuICAgICAgY29uc3QgbmV4dEJsb2NrID0gYmxvY2suZ2V0TmV4dEJsb2NrKClcbiAgICAgIGlmIChuZXh0QmxvY2spIHtcbiAgICAgICAgY29uc3QgbmV4dENvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShuZXh0QmxvY2spXG4gICAgICAgIGNvZGUgKz0gbmV4dENvZGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGVcbiAgICB9XG5cbiAgICAvLyBBcnRpZmFjdCB2YWx1ZSBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX2FydGlmYWN0X3ZhbHVlXCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9OQU1FXCIpIHx8IFwidW5uYW1lZF9hcnRpZmFjdFwiXG4gICAgICByZXR1cm4gYFwiJHtuYW1lfVwiYFxuICAgIH1cblxuICAgIC8vIEpvYiBUb29sIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfdG9vbFwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKSB8fCBcInVubmFtZWRfdG9vbFwiXG5cbiAgICAgIC8vIEZvciBzdGF0ZW1lbnQgYmxvY2tzLCByZXR1cm4gZnVsbCBjb2RlXG4gICAgICBsZXQgY29kZSA9IGAgICAgICAtICR7bmFtZX1cXG5gXG5cbiAgICAgIC8vIENoZWNrIGZvciBuZXh0IHRvb2wgYmxvY2tcbiAgICAgIGNvbnN0IG5leHRCbG9jayA9IGJsb2NrLmdldE5leHRCbG9jaygpXG4gICAgICBpZiAobmV4dEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG5leHRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUobmV4dEJsb2NrKVxuICAgICAgICBjb2RlICs9IG5leHRDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gQ29tbWFuZCBUb29sIHZhbHVlIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfdG9vbF92YWx1ZVwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKSB8fCBcInVubmFtZWRfdG9vbFwiXG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBzaGVsbCBjb21tYW5kIGluZGljYXRvclxuICAgICAgaWYgKG5hbWUgPT09IFwifFwiKSB7XG4gICAgICAgIHJldHVybiBgXCJ8XCJgXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBHaXRIdWIgQWN0aW9uIChlaXRoZXIgc3RhcnRzIHdpdGggXCJhY3Rpb25zL1wiIG9yIGNvbnRhaW5zIFwiQHZcIilcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJhY3Rpb25zL1wiKSB8fCBuYW1lLmluY2x1ZGVzKFwiQHZcIikpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuYW1lIGFzIGlzIC0gbm8gc3BlY2lhbCBoYW5kbGluZyBmb3IgZGlmZmVyZW50IGZvcm1hdHNcbiAgICAgICAgcmV0dXJuIGBcIiR7bmFtZX1cImBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBcIiR7bmFtZX1cImBcbiAgICB9XG5cbiAgICAvLyBJZlRoZW5FbHNlIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfaWZ0aGVuZWxzZVwiXSA9IChibG9jazogYW55KSA9PiB7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9DT05ESVRJT05cIikgfHwgXCJ0cnVlXCJcblxuICAgICAgLy8gR2V0IGNvbm5lY3RlZCBibG9ja3NcbiAgICAgIGNvbnN0IHRydWVCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX1RSVUVcIilcbiAgICAgIGNvbnN0IGZhbHNlQmxvY2sgPSBibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9GQUxTRVwiKVxuXG4gICAgICAvLyBHZW5lcmF0ZSBjb2RlIGZvciBHaXRIdWIgQWN0aW9ucyBpZiBjb25kaXRpb25zXG4gICAgICBsZXQgY29kZSA9IFwiXCJcblxuICAgICAgLy8gQWRkIHRydWUgYnJhbmNoIGlmIHByZXNlbnRcbiAgICAgIGlmICh0cnVlQmxvY2spIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgY29kZSBmb3IgdGhlIHRydWUgYnJhbmNoXG4gICAgICAgIGNvbnN0IHRydWVDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUodHJ1ZUJsb2NrKVxuXG4gICAgICAgIC8vIEluc2VydCB0aGUgY29uZGl0aW9uIGFmdGVyIGVhY2ggXCItIG5hbWU6XCIgbGluZVxuICAgICAgICBjb25zdCBsaW5lcyA9IHRydWVDb2RlLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgIGxldCBwcm9jZXNzZWRDb2RlID0gXCJcIlxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwcm9jZXNzZWRDb2RlICs9IGxpbmVzW2ldICsgXCJcXG5cIlxuXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIFwiLSBuYW1lOlwiIGxpbmUsIGFkZCB0aGUgY29uZGl0aW9uIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICBpZiAobGluZXNbaV0udHJpbSgpLnN0YXJ0c1dpdGgoXCItIG5hbWU6XCIpICYmIGkgKyAxIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgY29uZGl0aW9uIGJlZm9yZSB0aGUgbmV4dCBsaW5lICh3aGljaCBpcyB0eXBpY2FsbHkgJ3VzZXM6JyBvciAncnVuOicpXG4gICAgICAgICAgICBwcm9jZXNzZWRDb2RlICs9IGAgICAgICAgIGlmOiAke2NvbmRpdGlvbn1cXG5gXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29kZSArPSBwcm9jZXNzZWRDb2RlXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBmYWxzZSBicmFuY2ggaWYgcHJlc2VudFxuICAgICAgaWYgKGZhbHNlQmxvY2spIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgY29kZSBmb3IgdGhlIGZhbHNlIGJyYW5jaCwgd2l0aCBpbnZlcnRlZCBjb25kaXRpb25cbiAgICAgICAgY29uc3QgaW52ZXJ0ZWRDb25kaXRpb24gPSBgISgke2NvbmRpdGlvbn0pYFxuICAgICAgICBjb25zdCBmYWxzZUNvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShmYWxzZUJsb2NrKVxuXG4gICAgICAgIC8vIEluc2VydCB0aGUgaW52ZXJ0ZWQgY29uZGl0aW9uIGFmdGVyIGVhY2ggXCItIG5hbWU6XCIgbGluZVxuICAgICAgICBjb25zdCBsaW5lcyA9IGZhbHNlQ29kZS5zcGxpdChcIlxcblwiKVxuICAgICAgICBsZXQgcHJvY2Vzc2VkQ29kZSA9IFwiXCJcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkQ29kZSArPSBsaW5lc1tpXSArIFwiXFxuXCJcblxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBcIi0gbmFtZTpcIiBsaW5lLCBhZGQgdGhlIGludmVydGVkIGNvbmRpdGlvbiBvbiB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgaWYgKGxpbmVzW2ldLnRyaW0oKS5zdGFydHNXaXRoKFwiLSBuYW1lOlwiKSAmJiBpICsgMSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGludmVydGVkIGNvbmRpdGlvbiBiZWZvcmUgdGhlIG5leHQgbGluZSAod2hpY2ggaXMgdHlwaWNhbGx5ICd1c2VzOicgb3IgJ3J1bjonKVxuICAgICAgICAgICAgcHJvY2Vzc2VkQ29kZSArPSBgICAgICAgICBpZjogJHtpbnZlcnRlZENvbmRpdGlvbn1cXG5gXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29kZSArPSBwcm9jZXNzZWRDb2RlXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBuZXh0IGJsb2NrXG4gICAgICBjb25zdCBuZXh0QmxvY2sgPSBibG9jay5nZXROZXh0QmxvY2soKVxuICAgICAgaWYgKG5leHRCbG9jaykge1xuICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKG5leHRCbG9jaylcbiAgICAgICAgY29kZSArPSBuZXh0Q29kZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cblxuICAgIC8vIElmIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfaWZcIl0gPSAoYmxvY2s6IGFueSkgPT4ge1xuICAgICAgLy8gR2V0IGNvbm5lY3RlZCBibG9ja3NcbiAgICAgIGNvbnN0IGNvbW1hbmRCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0NPTU1BTkRcIilcbiAgICAgIGNvbnN0IGlmVGhlbkVsc2VCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0lGVEhFTkVMU0VcIilcblxuICAgICAgLy8gR2VuZXJhdGUgY29kZVxuICAgICAgbGV0IGNvZGUgPSBcIlwiXG5cbiAgICAgIC8vIEFkZCBjb21tYW5kIGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoY29tbWFuZEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoY29tbWFuZEJsb2NrKVxuICAgICAgICBjb2RlICs9IGNvbW1hbmRDb2RlXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBpZlRoZW5FbHNlIGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoaWZUaGVuRWxzZUJsb2NrKSB7XG4gICAgICAgIGNvbnN0IGlmVGhlbkVsc2VDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoaWZUaGVuRWxzZUJsb2NrKVxuICAgICAgICBjb2RlICs9IGlmVGhlbkVsc2VDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gRWxzZSBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX2Vsc2VcIl0gPSAoYmxvY2s6IGFueSkgPT4ge1xuICAgICAgLy8gR2V0IGNvbm5lY3RlZCBibG9ja3NcbiAgICAgIGNvbnN0IGNvbW1hbmRCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0NPTU1BTkRcIilcbiAgICAgIGNvbnN0IGlmVGhlbkVsc2VCbG9jayA9IGJsb2NrLmdldElucHV0VGFyZ2V0QmxvY2soXCJDT05UX0lGVEhFTkVMU0VcIilcblxuICAgICAgLy8gR2VuZXJhdGUgY29kZVxuICAgICAgbGV0IGNvZGUgPSBcIlwiXG5cbiAgICAgIC8vIEFkZCBjb21tYW5kIGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoY29tbWFuZEJsb2NrKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoY29tbWFuZEJsb2NrKVxuICAgICAgICBjb2RlICs9IGNvbW1hbmRDb2RlXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBpZlRoZW5FbHNlIGJsb2NrcyBpZiBwcmVzZW50XG4gICAgICBpZiAoaWZUaGVuRWxzZUJsb2NrKSB7XG4gICAgICAgIGNvbnN0IGlmVGhlbkVsc2VDb2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUoaWZUaGVuRWxzZUJsb2NrKVxuICAgICAgICBjb2RlICs9IGlmVGhlbkVsc2VDb2RlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gUGFyYW1ldGVyIGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfcGFyYW1ldGVyXCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtZXRlciA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX1BBUkFNRVRFUlwiKSB8fCBcInBhcmFtXCJcblxuICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgYmxvY2tcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gYmxvY2suZ2V0UGFyZW50KClcblxuICAgICAgLy8gQ2hlY2sgaWYgcGFyZW50IGlzIGEgY29tbWFuZCBibG9jayBhbmQgaXRzIHRvb2wgaXMgXCJ8XCJcbiAgICAgIGxldCBpc1NoZWxsQ29tbWFuZCA9IGZhbHNlXG4gICAgICBsZXQgaXNSZWd1bGFyQ29tbWFuZCA9IGZhbHNlXG5cbiAgICAgIGlmIChwYXJlbnRCbG9jayAmJiBwYXJlbnRCbG9jay50eXBlID09PSBcImVjb3JlX2NvbW1hbmRcIikge1xuICAgICAgICBjb25zdCB0b29sQmxvY2sgPSBwYXJlbnRCbG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9UT09MXCIpXG4gICAgICAgIGlmICh0b29sQmxvY2sgJiYgdG9vbEJsb2NrLnR5cGUgPT09IFwiZWNvcmVfdG9vbF92YWx1ZVwiKSB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSB0b29sQmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfTkFNRVwiKVxuICAgICAgICAgIGlzU2hlbGxDb21tYW5kID0gdG9vbE5hbWUgPT09IFwifFwiXG4gICAgICAgICAgaXNSZWd1bGFyQ29tbWFuZCA9IHRvb2xOYW1lICE9PSBcInxcIiAmJiAhdG9vbE5hbWUuaW5jbHVkZXMoXCJhY3Rpb25zL1wiKSAmJiAhdG9vbE5hbWUuaW5jbHVkZXMoXCJAdlwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIGNvZGUgd2l0aCBwcm9wZXIgaW5kZW50YXRpb24gYmFzZWQgb24gcGFyZW50XG4gICAgICBsZXQgY29kZVxuICAgICAgaWYgKGlzU2hlbGxDb21tYW5kKSB7XG4gICAgICAgIC8vIEZvciBzaGVsbCBjb21tYW5kcywgZWFjaCBwYXJhbWV0ZXIgaXMgYSBuZXcgbGluZSBvZiB0aGUgc2NyaXB0XG4gICAgICAgIGNvZGUgPSBgICAgICAgICAgICR7cGFyYW1ldGVyfVxcbmBcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWd1bGFyQ29tbWFuZCkge1xuICAgICAgICAvLyBGb3IgcmVndWxhciBjb21tYW5kcyBsaWtlIHlhcm4sIGp1c3QgcmV0dXJuIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgY29kZSA9IGAke3BhcmFtZXRlcn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWd1bGFyIHBhcmFtZXRlciBmb3JtYXQgZm9yIFwid2l0aDpcIiBzZWN0aW9uc1xuICAgICAgICBjb2RlID0gYCAgICAgICAgICAke3BhcmFtZXRlcn1cXG5gXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBuZXh0IHBhcmFtZXRlciBibG9ja1xuICAgICAgY29uc3QgbmV4dEJsb2NrID0gYmxvY2suZ2V0TmV4dEJsb2NrKClcbiAgICAgIGlmIChuZXh0QmxvY2spIHtcbiAgICAgICAgY29uc3QgbmV4dENvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShuZXh0QmxvY2spXG4gICAgICAgIGNvZGUgKz0gbmV4dENvZGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGVcbiAgICB9XG5cbiAgICAvLyBBZGQgYSBzcGVjaWFsIGZ1bmN0aW9uIHRvIGhhbmRsZSBzaGVsbCBjb21tYW5kIHBhcmFtZXRlcnNcbiAgICBFY29yZS5wcm9jZXNzU2hlbGxQYXJhbWV0ZXJzID0gKHBhcmFtQmxvY2s6IGFueSkgPT4ge1xuICAgICAgaWYgKCFwYXJhbUJsb2NrKSB7XG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhbGwgcGFyYW1ldGVycyBhcyBhIHNpbmdsZSBzdHJpbmdcbiAgICAgIGNvbnN0IHBhcmFtQ29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKHBhcmFtQmxvY2spXG5cbiAgICAgIC8vIFNwbGl0IGludG8gbGluZXMgYW5kIGluZGVudCBlYWNoIGxpbmUgcHJvcGVybHlcbiAgICAgIGNvbnN0IHBhcmFtTGluZXMgPSBwYXJhbUNvZGUuc3BsaXQoXCJcXG5cIilcbiAgICAgIGxldCBpbmRlbnRlZFBhcmFtcyA9IFwiXCJcblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHBhcmFtTGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgLy8gQWRkIGV4YWN0bHkgMTAgc3BhY2VzICg4IHNwYWNlcyArIDIgZm9yIHByb3BlciBsZXZlbCkgZm9yIGVhY2ggc2hlbGwgY29tbWFuZFxuICAgICAgICAgIGluZGVudGVkUGFyYW1zICs9IGAgICAgICAgICAgJHtsaW5lLnRyaW0oKX1cXG5gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGVudGVkUGFyYW1zXG4gICAgfVxuXG4gICAgLy8gQWRkIGEgc3BlY2lhbCBmdW5jdGlvbiB0byBoYW5kbGUgcmVndWxhciBjb21tYW5kIHBhcmFtZXRlcnNcbiAgICBFY29yZS5wcm9jZXNzUmVndWxhclBhcmFtZXRlcnMgPSAocGFyYW1CbG9jazogYW55KSA9PiB7XG4gICAgICBpZiAoIXBhcmFtQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGFsbCBwYXJhbWV0ZXJzIGFzIGEgc2luZ2xlIHN0cmluZ1xuICAgICAgY29uc3QgcGFyYW1Db2RlID0gd2luZG93LkJsb2NrbHkuRWNvcmUuYmxvY2tUb0NvZGUocGFyYW1CbG9jaylcblxuICAgICAgLy8gU3BsaXQgaW50byBsaW5lcyBhbmQgam9pbiB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICBjb25zdCBwYXJhbXMgPSBwYXJhbUNvZGVcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS50cmltKCkpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuam9pbihcIiBcIilcblxuICAgICAgcmV0dXJuIHBhcmFtc1xuICAgIH1cblxuICAgIC8vIFBlcm1pc3Npb24gYmxvY2sgZ2VuZXJhdG9yXG4gICAgRWNvcmVbXCJlY29yZV9wZXJtaXNzaW9uXCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGJsb2NrLmdldEZpZWxkVmFsdWUoXCJBVFRSX0tFWVwiKSB8fCBcIlBFUk1fS0VZXCJcbiAgICAgIGNvbnN0IHZhbHVlID0gYmxvY2suZ2V0RmllbGRWYWx1ZShcIkFUVFJfVkFMVUVcIikgfHwgXCJ2YWx1ZVwiXG5cbiAgICAgIC8vIEdlbmVyYXRlIGNvZGUgd2l0aCBwcm9wZXIgaW5kZW50YXRpb25cbiAgICAgIGxldCBjb2RlID0gYCAgJHtrZXl9OiAke3ZhbHVlfVxcbmBcblxuICAgICAgLy8gQ2hlY2sgZm9yIG5leHQgcGVybWlzc2lvbiBibG9ja1xuICAgICAgY29uc3QgbmV4dEJsb2NrID0gYmxvY2suZ2V0TmV4dEJsb2NrKClcbiAgICAgIGlmIChuZXh0QmxvY2spIHtcbiAgICAgICAgY29uc3QgbmV4dENvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShuZXh0QmxvY2spXG4gICAgICAgIGNvZGUgKz0gbmV4dENvZGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGVcbiAgICB9XG5cbiAgICAvLyBKb2IgZGVwZW5kZW5jeSBibG9jayBnZW5lcmF0b3JcbiAgICBFY29yZVtcImVjb3JlX2pvYl9kZXBlbmRlbmN5XCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9OQU1FXCIpIHx8IFwidW5uYW1lZF9qb2JcIlxuXG4gICAgICAvLyBTdGFydCB3aXRoIHRoZSBjdXJyZW50IGpvYiBuYW1lXG4gICAgICBsZXQgY29kZSA9IGBcIiR7bmFtZX1cImBcblxuICAgICAgLy8gQ2hlY2sgZm9yIG5leHQgZGVwZW5kZW5jeSBibG9ja1xuICAgICAgY29uc3QgbmV4dEJsb2NrID0gYmxvY2suZ2V0TmV4dEJsb2NrKClcbiAgICAgIGlmIChuZXh0QmxvY2spIHtcbiAgICAgICAgY29uc3QgbmV4dENvZGUgPSB3aW5kb3cuQmxvY2tseS5FY29yZS5ibG9ja1RvQ29kZShuZXh0QmxvY2spXG4gICAgICAgIGNvZGUgKz0gYCwgJHtuZXh0Q29kZX1gXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuXG4gICAgLy8gQ29tbWFuZCBkZXBlbmRlbmN5IGJsb2NrIGdlbmVyYXRvclxuICAgIEVjb3JlW1wiZWNvcmVfY29tbWFuZF9kZXBlbmRlbmN5XCJdID0gKGJsb2NrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9jay5nZXRGaWVsZFZhbHVlKFwiQVRUUl9OQU1FXCIpIHx8IFwidW5uYW1lZF9jb21tYW5kXCJcblxuICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgY3VycmVudCBjb21tYW5kIG5hbWVcbiAgICAgIGxldCBjb2RlID0gYFwiJHtuYW1lfVwiYFxuXG4gICAgICAvLyBDaGVjayBmb3IgbmV4dCBkZXBlbmRlbmN5IGJsb2NrXG4gICAgICBjb25zdCBuZXh0QmxvY2sgPSBibG9jay5nZXROZXh0QmxvY2soKVxuICAgICAgaWYgKG5leHRCbG9jaykge1xuICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKG5leHRCbG9jaylcbiAgICAgICAgY29kZSArPSBgLCAke25leHRDb2RlfWBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGVcbiAgICB9XG5cbiAgICAvLyBBZGQgYSBibG9ja1RvQ29kZSBmdW5jdGlvbiB0byBoYW5kbGUgYW55IGJsb2NrXG4gICAgRWNvcmUuYmxvY2tUb0NvZGUgPSAoYmxvY2s6IGFueSkgPT4ge1xuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgZ2VuZXJhdG9yIGZvciB0aGlzIGJsb2NrIHR5cGVcbiAgICAgIGlmIChFY29yZVtibG9jay50eXBlXSkge1xuICAgICAgICByZXR1cm4gRWNvcmVbYmxvY2sudHlwZV0oYmxvY2spXG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgY2FzZSBpZiBubyBnZW5lcmF0b3IgaXMgZm91bmRcbiAgICAgIGNvbnNvbGUud2FybihgTm8gZ2VuZXJhdG9yIGZvdW5kIGZvciBibG9jayB0eXBlOiAke2Jsb2NrLnR5cGV9YClcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY29kZSBmcm9tIHRoZSB3b3Jrc3BhY2VcbiAgc3RhdGljIGdlbmVyYXRlQ29kZSh3b3Jrc3BhY2U6IGFueSk6IHN0cmluZyB7XG4gICAgLy8gTWFrZSBzdXJlIGdlbmVyYXRvcnMgYXJlIGluaXRpYWxpemVkXG4gICAgdGhpcy5pbml0KClcblxuICAgIC8vIEdldCBhbGwgdG9wLWxldmVsIGJsb2Nrc1xuICAgIGNvbnN0IHRvcEJsb2NrcyA9IHdvcmtzcGFjZS5nZXRUb3BCbG9ja3ModHJ1ZSlcblxuICAgIC8vIEdlbmVyYXRlIGNvZGUgZm9yIGVhY2ggdG9wLWxldmVsIGJsb2NrXG4gICAgbGV0IGNvZGUgPSBcIiMgR2VuZXJhdGVkIENJL0NEIFBpcGVsaW5lIFlBTUxcXG5cIlxuICAgIGNvZGUgKz0gXCIjIFRoaXMgWUFNTCBpcyBjb21wYXRpYmxlIHdpdGggR2l0SHViIEFjdGlvbnNcXG5cXG5cIlxuXG4gICAgZm9yIChjb25zdCBibG9jayBvZiB0b3BCbG9ja3MpIHtcbiAgICAgIGlmICh3aW5kb3cuQmxvY2tseS5FY29yZVtibG9jay50eXBlXSkge1xuICAgICAgICBjb2RlICs9IHdpbmRvdy5CbG9ja2x5LkVjb3JlLmJsb2NrVG9Db2RlKGJsb2NrKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGluZGVudCBjb2RlXG5mdW5jdGlvbiBpbmRlbnRDb2RlKGNvZGU6IHN0cmluZywgaW5kZW50TGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGluZGVudCA9IFwiICBcIi5yZXBlYXQoaW5kZW50TGV2ZWwpXG4gIHJldHVybiBjb2RlXG4gICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgaWYgKGxpbmUudHJpbSgpID09PSBcIlwiKSByZXR1cm4gbGluZVxuICAgICAgcmV0dXJuIGluZGVudCArIGxpbmVcbiAgICB9KVxuICAgIC5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEFkZCBCbG9ja2x5IHRvIHRoZSB3aW5kb3cgdHlwZVxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBCbG9ja2x5OiBhbnlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImdlbmVyYXRvckluaXRpYWxpemVkIiwiZ2VuZXJhdGVSYW5kb21JZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiRWNvcmVHZW5lcmF0b3IiLCJpbml0Iiwid2luZG93IiwiQmxvY2tseSIsIkVjb3JlIiwiZGVmaW5lR2VuZXJhdG9ycyIsImNvbnNvbGUiLCJsb2ciLCJibG9jayIsIm5hbWUiLCJnZXRGaWVsZFZhbHVlIiwiY29uY3VycmVudCIsIndoZW5CbG9jayIsImdldElucHV0VGFyZ2V0QmxvY2siLCJqb2JCbG9jayIsInRvb2xCbG9jayIsImVudkJsb2NrIiwicGVybUJsb2NrIiwiY29kZSIsIndoZW5Db2RlIiwiYmxvY2tUb0NvZGUiLCJqb2JDb2RlIiwidG9vbENvZGUiLCJlbnZDb2RlIiwicGVybUNvZGUiLCJ0cmltIiwiYWxsb3dGYWlsdXJlIiwiY29tbWFuZEJsb2NrIiwiaWZUaGVuRWxzZUJsb2NrIiwiaW5wdXRCbG9jayIsIm91dHB1dEJsb2NrIiwiZGVwZW5kc0Jsb2NrIiwiZGVzY3JpcHRpb24iLCJ0b29sTmFtZSIsImNvbW1hbmRDb2RlIiwiaW5kZW50Q29kZSIsImlmVGhlbkVsc2VDb2RlIiwiaW5wdXRDb2RlIiwib3V0cHV0Q29kZSIsImRlcGVuZHNDb2RlIiwibmV4dEJsb2NrIiwiZ2V0TmV4dEJsb2NrIiwibmV4dENvZGUiLCJwYXJhbUJsb2NrIiwidG9vbFZhbHVlIiwicmVwbGFjZSIsInBhcmFtQ29kZSIsInByb2Nlc3NTaGVsbFBhcmFtZXRlcnMiLCJpbmNsdWRlcyIsImNvbW1hbmQiLCJwcm9jZXNzUmVndWxhclBhcmFtZXRlcnMiLCJrZXkiLCJ2YWx1ZSIsInRyaWdnZXIiLCJ0aW1lciIsInN0YXJ0c1dpdGgiLCJjb25kaXRpb24iLCJ0cnVlQmxvY2siLCJmYWxzZUJsb2NrIiwidHJ1ZUNvZGUiLCJsaW5lcyIsInNwbGl0IiwicHJvY2Vzc2VkQ29kZSIsImkiLCJsZW5ndGgiLCJpbnZlcnRlZENvbmRpdGlvbiIsImZhbHNlQ29kZSIsInBhcmFtZXRlciIsInBhcmVudEJsb2NrIiwiZ2V0UGFyZW50IiwiaXNTaGVsbENvbW1hbmQiLCJpc1JlZ3VsYXJDb21tYW5kIiwidHlwZSIsInBhcmFtTGluZXMiLCJpbmRlbnRlZFBhcmFtcyIsImxpbmUiLCJwYXJhbXMiLCJmaWx0ZXIiLCJtYXAiLCJqb2luIiwid2FybiIsImdlbmVyYXRlQ29kZSIsIndvcmtzcGFjZSIsInRvcEJsb2NrcyIsImdldFRvcEJsb2NrcyIsImluZGVudExldmVsIiwiaW5kZW50IiwicmVwZWF0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./blockly-code-generator.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./blockly-workspace.tsx":
/*!*******************************!*\
  !*** ./blockly-workspace.tsx ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_script__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/script */ \"(app-pages-browser)/./node_modules/next/dist/api/script.js\");\n/* harmony import */ var _ecore_blocks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ecore-blocks */ \"(app-pages-browser)/./ecore-blocks.tsx\");\n/* harmony import */ var _blockly_code_generator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blockly-code-generator */ \"(app-pages-browser)/./blockly-code-generator.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n// Default pipeline configuration JSON\nconst DEFAULT_PIPELINE_JSON = {\n    blocks: {\n        languageVersion: 0,\n        blocks: [\n            {\n                type: \"ecore_pipeline\",\n                id: \"z[Ib{|:nKA_X-((s~Y7y\",\n                x: 75,\n                y: 24,\n                fields: {\n                    ATTR_NAME: \"default_pipeline\",\n                    ATTR_CONCURRENT: false\n                },\n                inputs: {\n                    CONT_WHEN: {\n                        block: {\n                            type: \"ecore_when\",\n                            id: \"DTaRHa_sIjpJ}I/yuaf3\",\n                            fields: {\n                                ATTR_NAME: \"on_workflow_dispatch\",\n                                ATTR_TRIGGER: \"workflow_dispatch\",\n                                ATTR_TIMER: \"\"\n                            }\n                        }\n                    },\n                    CONT_JOB: {\n                        block: {\n                            type: \"ecore_job\",\n                            id: \"g9%$Xvx-66h,Oh/PL!Ki\",\n                            fields: {\n                                ATTR_NAME: \"build\",\n                                ATTR_ALLOWFAILURE: false,\n                                ATTR_DESCRIPTION: \"Build and test the application\"\n                            },\n                            inputs: {\n                                CONT_TOOL: {\n                                    block: {\n                                        type: \"ecore_tool\",\n                                        id: \"fU!MZF|^*4yx9Zdg+SXA\",\n                                        fields: {\n                                            ATTR_NAME: \"ubuntu-latest\"\n                                        }\n                                    }\n                                },\n                                CONT_COMMAND: {\n                                    block: {\n                                        type: \"ecore_command\",\n                                        id: \"x~rd@7X]hL(FQntuYO:`\",\n                                        fields: {\n                                            ATTR_NAME: \"setup\"\n                                        },\n                                        inputs: {\n                                            CONT_TOOL: {\n                                                block: {\n                                                    type: \"ecore_tool_value\",\n                                                    id: \"R(v=JXNbA4YBt?wxmnPb\",\n                                                    fields: {\n                                                        ATTR_NAME: \"npm\"\n                                                    }\n                                                }\n                                            },\n                                            CONT_PARAMETER: {\n                                                block: {\n                                                    type: \"ecore_parameter\",\n                                                    id: \"w(*oscU@^g#t^yE5@C5V\",\n                                                    fields: {\n                                                        ATTR_PARAMETER: \"install\"\n                                                    },\n                                                    next: {\n                                                        block: {\n                                                            type: \"ecore_parameter\",\n                                                            id: \"N~m$CM,!TVZ+P.4Ai;aL\",\n                                                            fields: {\n                                                                ATTR_PARAMETER: \"install --ci\"\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        ]\n    }\n};\n// Add these constants at the top of the file, after the imports:\n// Constants for localStorage keys\nconst STORAGE_KEY_WORKSPACE = \"visualci_workspace\";\n// This component will be loaded dynamically to avoid SSR issues with Blockly\nconst BlocklyWorkspace = /*#__PURE__*/ _s((0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_c = _s((param, ref)=>{\n    let { onChange, initialXml, onWorkspaceLoaded } = param;\n    _s();\n    const blocklyDiv = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [workspace, setWorkspace] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [blocklyLoaded, setBlocklyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Function to load the default pipeline structure\n    const loadDefaultPipeline = (workspace)=>{\n        try {\n            // Clear the workspace first\n            workspace.clear();\n            // Load the default pipeline JSON\n            window.Blockly.serialization.workspaces.load(DEFAULT_PIPELINE_JSON, workspace);\n            // Center the workspace on the pipeline block\n            const blocks = workspace.getTopBlocks(false);\n            if (blocks.length > 0) {\n                workspace.centerOnBlock(blocks[0].id);\n            }\n            return blocks[0] // Return the pipeline block\n            ;\n        } catch (error) {\n            console.error(\"Error loading default pipeline:\", error);\n            // Fallback to creating a simple pipeline if loading fails\n            const pipelineBlock = workspace.newBlock(\"ecore_pipeline\");\n            pipelineBlock.setFieldValue(\"default_pipeline\", \"ATTR_NAME\");\n            pipelineBlock.initSvg();\n            pipelineBlock.render();\n            pipelineBlock.moveBy(50, 50);\n            return pipelineBlock;\n        }\n    };\n    // Expose methods via ref\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, {\n        \"BlocklyWorkspace.useImperativeHandle\": ()=>({\n                serializeWorkspace: ({\n                    \"BlocklyWorkspace.useImperativeHandle\": ()=>{\n                        if (!workspace) return \"\";\n                        try {\n                            // Serialize the workspace to JSON\n                            const json = window.Blockly.serialization.workspaces.save(workspace);\n                            const jsonString = JSON.stringify(json, null, 2);\n                            // Also save directly to localStorage to ensure it's always saved\n                            localStorage.setItem(STORAGE_KEY_WORKSPACE, jsonString);\n                            return jsonString;\n                        } catch (error) {\n                            console.error(\"Error serializing workspace:\", error);\n                            return \"\";\n                        }\n                    }\n                })[\"BlocklyWorkspace.useImperativeHandle\"],\n                loadWorkspace: ({\n                    \"BlocklyWorkspace.useImperativeHandle\": (jsonData)=>{\n                        if (!workspace) return;\n                        try {\n                            console.log(\"Loading workspace from JSON data\");\n                            // Clear the workspace first\n                            workspace.clear();\n                            // Parse the JSON data\n                            const json = JSON.parse(jsonData);\n                            // Load the workspace from JSON\n                            window.Blockly.serialization.workspaces.load(json, workspace);\n                            // Center the workspace view\n                            const blocks = workspace.getTopBlocks(false);\n                            if (blocks.length > 0) {\n                                workspace.centerOnBlock(blocks[0].id);\n                            }\n                            // Trigger onChange to update the generated code\n                            if (onChange) {\n                                const xml = window.Blockly.Xml.workspaceToDom(workspace);\n                                const xmlText = window.Blockly.Xml.domToText(xml);\n                                const code = _blockly_code_generator__WEBPACK_IMPORTED_MODULE_4__.EcoreGenerator.generateCode(workspace);\n                                onChange(xmlText, code);\n                            }\n                        } catch (error) {\n                            console.error(\"Error loading workspace from JSON:\", error);\n                            alert(\"Error loading workspace: Invalid JSON format or incompatible workspace data\");\n                        }\n                    }\n                })[\"BlocklyWorkspace.useImperativeHandle\"],\n                clearWorkspace: ({\n                    \"BlocklyWorkspace.useImperativeHandle\": ()=>{\n                        if (!workspace) return;\n                        // Just clear the workspace completely without loading the default pipeline\n                        workspace.clear();\n                        // Trigger onChange to update the generated code\n                        if (onChange) {\n                            const xml = window.Blockly.Xml.workspaceToDom(workspace);\n                            const xmlText = window.Blockly.Xml.domToText(xml);\n                            const code = _blockly_code_generator__WEBPACK_IMPORTED_MODULE_4__.EcoreGenerator.generateCode(workspace);\n                            onChange(xmlText, code);\n                        }\n                    }\n                })[\"BlocklyWorkspace.useImperativeHandle\"]\n            })\n    }[\"BlocklyWorkspace.useImperativeHandle\"]);\n    // Handle script load event\n    const handleScriptLoad = ()=>{\n        console.log(\"Blockly script loaded\");\n        setBlocklyLoaded(true);\n    };\n    // Initialize Blockly after the script has loaded\n    const initBlockly = ()=>{\n        if (!blocklyDiv.current || !window.Blockly) return;\n        try {\n            console.log(\"Initializing Blockly...\", window.Blockly);\n            // Register custom blocks\n            _ecore_blocks__WEBPACK_IMPORTED_MODULE_3__.ECORE_BLOCKS.forEach((block)=>{\n                window.Blockly.Blocks[block.type] = {\n                    init: function() {\n                        this.jsonInit(block);\n                    }\n                };\n            });\n            // Create workspace with responsive settings\n            const newWorkspace = window.Blockly.inject(blocklyDiv.current, {\n                toolbox: _ecore_blocks__WEBPACK_IMPORTED_MODULE_3__.ECORE_TOOLBOX,\n                grid: {\n                    spacing: 20,\n                    length: 3,\n                    colour: \"#ccc\",\n                    snap: true\n                },\n                zoom: {\n                    controls: true,\n                    wheel: true,\n                    startScale: window.innerWidth < 768 ? 0.7 : 1.0,\n                    maxScale: 3,\n                    minScale: 0.3,\n                    scaleSpeed: 1.2\n                },\n                trashcan: true,\n                scrollbars: true,\n                sounds: false,\n                move: {\n                    scrollbars: true,\n                    drag: true,\n                    wheel: true\n                },\n                // Enable strict type checking\n                typeCheck: true\n            });\n            // Add automatic block creation for job and command blocks\n            newWorkspace.addChangeListener((event)=>{\n                // Only handle block creation events\n                if (event.type === window.Blockly.Events.BLOCK_CREATE) {\n                    // Get the created block\n                    const block = newWorkspace.getBlockById(event.blockId);\n                    if (block) {\n                        // Check if this is a newly created block or a copied block\n                        // If it's a copied block, it will already have connections\n                        const isNewlyCreated = !event.ids || event.ids.length <= 1;\n                        // If a job block is created, automatically add a tool and command block to it\n                        if (block.type === \"ecore_job\") {\n                            // Add a tool block to the job if the tool input is empty\n                            if (!block.getInputTargetBlock(\"CONT_TOOL\")) {\n                                // Create a job tool block\n                                const jobToolBlock = newWorkspace.newBlock(\"ecore_tool\");\n                                jobToolBlock.initSvg();\n                                jobToolBlock.render();\n                                // Set a default name for the job tool\n                                jobToolBlock.setFieldValue(\"ubuntu-latest\", \"ATTR_NAME\");\n                                // Connect the tool block to the job block\n                                const jobToolConnection = block.getInput(\"CONT_TOOL\").connection;\n                                const jobToolBlockConnection = jobToolBlock.previousConnection;\n                                jobToolConnection.connect(jobToolBlockConnection);\n                            }\n                            // Check if the command input is empty\n                            if (!block.getInputTargetBlock(\"CONT_COMMAND\")) {\n                                // Create a command block\n                                const commandBlock = newWorkspace.newBlock(\"ecore_command\");\n                                commandBlock.initSvg();\n                                commandBlock.render();\n                                // Set a default name for the command\n                                commandBlock.setFieldValue(\"default_command\", \"ATTR_NAME\");\n                                // Connect the command block to the job block\n                                const commandConnection = block.getInput(\"CONT_COMMAND\").connection;\n                                const commandBlockConnection = commandBlock.previousConnection;\n                                commandConnection.connect(commandBlockConnection);\n                                // Create a command tool block for the command\n                                const toolBlock = newWorkspace.newBlock(\"ecore_tool_value\");\n                                toolBlock.initSvg();\n                                toolBlock.render();\n                                // Set a default name for the command tool\n                                toolBlock.setFieldValue(\"npm\", \"ATTR_NAME\");\n                                // Connect the tool block to the command block\n                                const toolConnection = commandBlock.getInput(\"CONT_TOOL\").connection;\n                                const toolBlockConnection = toolBlock.outputConnection;\n                                toolConnection.connect(toolBlockConnection);\n                                // Create a parameter block for the command\n                                const parameterBlock = newWorkspace.newBlock(\"ecore_parameter\");\n                                parameterBlock.initSvg();\n                                parameterBlock.render();\n                                // Set a default value for the parameter\n                                parameterBlock.setFieldValue(\"install\", \"ATTR_PARAMETER\");\n                                // Connect the parameter block to the command block\n                                const parameterConnection = commandBlock.getInput(\"CONT_PARAMETER\").connection;\n                                const parameterBlockConnection = parameterBlock.previousConnection;\n                                parameterConnection.connect(parameterBlockConnection);\n                            }\n                        } else if (block.type === \"ecore_command\" && isNewlyCreated) {\n                            // Only add child blocks if the command doesn't already have them\n                            // This prevents duplicate blocks when copying/pasting\n                            // Check if the tool input is empty\n                            if (!block.getInputTargetBlock(\"CONT_TOOL\")) {\n                                // Create a command tool block\n                                const toolBlock = newWorkspace.newBlock(\"ecore_tool_value\");\n                                toolBlock.initSvg();\n                                toolBlock.render();\n                                // Set a default name for the command tool\n                                toolBlock.setFieldValue(\"npm\", \"ATTR_NAME\");\n                                // Connect the tool block to the command block\n                                const commandBlock = block // Assign the block to commandBlock\n                                ;\n                                const toolConnection = commandBlock.getInput(\"CONT_TOOL\").connection;\n                                const toolBlockConnection = toolBlock.outputConnection;\n                                toolConnection.connect(toolBlockConnection);\n                            }\n                            // Check if the parameter input is empty\n                            if (!block.getInputTargetBlock(\"CONT_PARAMETER\")) {\n                                // Create a parameter block\n                                const parameterBlock = newWorkspace.newBlock(\"ecore_parameter\");\n                                parameterBlock.initSvg();\n                                parameterBlock.render();\n                                // Set a default value for the parameter\n                                parameterBlock.setFieldValue(\"install\", \"ATTR_PARAMETER\");\n                                // Connect the parameter block to the command block\n                                const parameterConnection = block.getInput(\"CONT_PARAMETER\").connection;\n                                const parameterBlockConnection = parameterBlock.previousConnection;\n                                parameterConnection.connect(parameterBlockConnection);\n                            }\n                        }\n                    }\n                }\n            });\n            // Check for saved workspace in localStorage first\n            const savedWorkspace = localStorage.getItem(STORAGE_KEY_WORKSPACE);\n            if (savedWorkspace) {\n                try {\n                    console.log(\"Found saved workspace in localStorage, loading it...\");\n                    // Parse and load the saved workspace\n                    const json = JSON.parse(savedWorkspace);\n                    window.Blockly.serialization.workspaces.load(json, newWorkspace);\n                    // Center the workspace on the first block\n                    const blocks = newWorkspace.getTopBlocks(false);\n                    if (blocks.length > 0) {\n                        newWorkspace.centerOnBlock(blocks[0].id);\n                    }\n                } catch (error) {\n                    console.error(\"Error loading workspace from localStorage:\", error);\n                    // If there's an error loading saved workspace, load the default pipeline\n                    loadDefaultPipeline(newWorkspace);\n                }\n            } else if (initialXml) {\n                // If no saved workspace but initialXml is provided, load that\n                const xml = window.Blockly.Xml.textToDom(initialXml);\n                window.Blockly.Xml.domToWorkspace(xml, newWorkspace);\n            } else {\n                // If no saved workspace or initialXml, load the default pipeline\n                console.log(\"No saved workspace found, loading default pipeline\");\n                loadDefaultPipeline(newWorkspace);\n            }\n            // Initialize the code generator\n            if (window.Blockly.Ecore === undefined) {\n                _blockly_code_generator__WEBPACK_IMPORTED_MODULE_4__.EcoreGenerator.init();\n            }\n            // Set up change listener with debounce to prevent rapid updates\n            let changeTimeout = null;\n            if (onChange) {\n                newWorkspace.addChangeListener((event)=>{\n                    // Only process events that change the workspace content\n                    if (event.type === window.Blockly.Events.BLOCK_MOVE || event.type === window.Blockly.Events.BLOCK_CHANGE || event.type === window.Blockly.Events.BLOCK_CREATE || event.type === window.Blockly.Events.BLOCK_DELETE) {\n                        // Clear previous timeout\n                        if (changeTimeout) {\n                            clearTimeout(changeTimeout);\n                        }\n                        // Set new timeout to debounce rapid changes\n                        changeTimeout = setTimeout(()=>{\n                            const xml = window.Blockly.Xml.workspaceToDom(newWorkspace);\n                            const xmlText = window.Blockly.Xml.domToText(xml);\n                            // Generate code using our custom generator\n                            const code = _blockly_code_generator__WEBPACK_IMPORTED_MODULE_4__.EcoreGenerator.generateCode(newWorkspace);\n                            onChange(xmlText, code);\n                        }, 300);\n                    }\n                });\n            }\n            // Handle window resize\n            const handleResize = ()=>{\n                window.Blockly.svgResize(newWorkspace);\n            };\n            window.addEventListener(\"resize\", handleResize);\n            // Store workspace for cleanup\n            setWorkspace(newWorkspace);\n            // Notify parent that workspace is loaded\n            if (onWorkspaceLoaded) {\n                onWorkspaceLoaded(newWorkspace);\n            }\n            // Return cleanup function\n            return ()=>{\n                window.removeEventListener(\"resize\", handleResize);\n                if (changeTimeout) {\n                    clearTimeout(changeTimeout);\n                }\n                if (newWorkspace) {\n                    newWorkspace.dispose();\n                }\n            };\n        } catch (error) {\n            console.error(\"Error initializing Blockly:\", error);\n        }\n    };\n    // Initialize Blockly when the component mounts and the script is loaded\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"BlocklyWorkspace.useEffect\": ()=>{\n            if (blocklyLoaded && blocklyDiv.current && !workspace) {\n                initBlockly();\n            }\n        }\n    }[\"BlocklyWorkspace.useEffect\"], [\n        blocklyLoaded,\n        blocklyDiv,\n        workspace,\n        initialXml,\n        onChange,\n        onWorkspaceLoaded\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_script__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                src: \"https://cdn.jsdelivr.net/npm/blockly@11.2.2/blockly.min.js\",\n                onLoad: handleScriptLoad,\n                onError: (e)=>console.error(\"Error loading Blockly script:\", e),\n                strategy: \"afterInteractive\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\hugoa\\\\Desktop\\\\repos\\\\repos\\\\metamodel2blockly\\\\generated\\\\bowling_alley-visualci\\\\blockly-workspace.tsx\",\n                lineNumber: 485,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: blocklyDiv,\n                className: \"w-full h-full min-h-[300px] sm:min-h-[400px]\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\hugoa\\\\Desktop\\\\repos\\\\repos\\\\metamodel2blockly\\\\generated\\\\bowling_alley-visualci\\\\blockly-workspace.tsx\",\n                lineNumber: 491,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true);\n}, \"cIZADqA0C1zUU7wgEInH29/zbk4=\")), \"cIZADqA0C1zUU7wgEInH29/zbk4=\");\n_c1 = BlocklyWorkspace;\nBlocklyWorkspace.displayName = \"BlocklyWorkspace\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlocklyWorkspace);\nvar _c, _c1;\n$RefreshReg$(_c, \"BlocklyWorkspace$forwardRef\");\n$RefreshReg$(_c1, \"BlocklyWorkspace\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2Jsb2NrbHktd29ya3NwYWNlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDb0Y7QUFDcEQ7QUFDNEI7QUFDSDtBQWdCekQsc0NBQXNDO0FBQ3RDLE1BQU1TLHdCQUF3QjtJQUM1QkMsUUFBUTtRQUNOQyxpQkFBaUI7UUFDakJELFFBQVE7WUFDTjtnQkFDRUUsTUFBTTtnQkFDTkMsSUFBSTtnQkFDSkMsR0FBRztnQkFDSEMsR0FBRztnQkFDSEMsUUFBUTtvQkFDTkMsV0FBVztvQkFDWEMsaUJBQWlCO2dCQUNuQjtnQkFDQUMsUUFBUTtvQkFDTkMsV0FBVzt3QkFDVEMsT0FBTzs0QkFDTFQsTUFBTTs0QkFDTkMsSUFBSTs0QkFDSkcsUUFBUTtnQ0FDTkMsV0FBVztnQ0FDWEssY0FBYztnQ0FDZEMsWUFBWTs0QkFDZDt3QkFDRjtvQkFDRjtvQkFDQUMsVUFBVTt3QkFDUkgsT0FBTzs0QkFDTFQsTUFBTTs0QkFDTkMsSUFBSTs0QkFDSkcsUUFBUTtnQ0FDTkMsV0FBVztnQ0FDWFEsbUJBQW1CO2dDQUNuQkMsa0JBQWtCOzRCQUNwQjs0QkFDQVAsUUFBUTtnQ0FDTlEsV0FBVztvQ0FDVE4sT0FBTzt3Q0FDTFQsTUFBTTt3Q0FDTkMsSUFBSTt3Q0FDSkcsUUFBUTs0Q0FDTkMsV0FBVzt3Q0FDYjtvQ0FDRjtnQ0FDRjtnQ0FDQVcsY0FBYztvQ0FDWlAsT0FBTzt3Q0FDTFQsTUFBTTt3Q0FDTkMsSUFBSTt3Q0FDSkcsUUFBUTs0Q0FDTkMsV0FBVzt3Q0FDYjt3Q0FDQUUsUUFBUTs0Q0FDTlEsV0FBVztnREFDVE4sT0FBTztvREFDTFQsTUFBTTtvREFDTkMsSUFBSTtvREFDSkcsUUFBUTt3REFDTkMsV0FBVztvREFDYjtnREFDRjs0Q0FDRjs0Q0FDQVksZ0JBQWdCO2dEQUNkUixPQUFPO29EQUNMVCxNQUFNO29EQUNOQyxJQUFJO29EQUNKRyxRQUFRO3dEQUNOYyxnQkFBZ0I7b0RBQ2xCO29EQUNBQyxNQUFNO3dEQUNKVixP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O2dCQUNMNUMsT0FBTzBHLG1CQUFtQixDQUFDLFVBQVVIO2dCQUNyQyxJQUFJTixlQUFlO29CQUNqQkksYUFBYUo7Z0JBQ2Y7Z0JBQ0EsSUFBSXJELGNBQWM7b0JBQ2hCQSxhQUFhK0QsT0FBTztnQkFDdEI7WUFDRjtRQUNGLEVBQUUsT0FBT25HLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDL0M7SUFDRjtJQUVBLHdFQUF3RTtJQUN4RXJELGdEQUFTQTtzQ0FBQztZQUNSLElBQUl5QyxpQkFBaUJILFdBQVc4QyxPQUFPLElBQUksQ0FBQzdDLFdBQVc7Z0JBQ3JENEM7WUFDRjtRQUNGO3FDQUFHO1FBQUMxQztRQUFlSDtRQUFZQztRQUFXSDtRQUFZRDtRQUFVRTtLQUFrQjtJQUVsRixxQkFDRTs7MEJBQ0UsOERBQUNoQyxtREFBTUE7Z0JBQ0xvSixLQUFJO2dCQUNKQyxRQUFReEU7Z0JBQ1J5RSxTQUFTLENBQUNDLElBQU10RyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDdUc7Z0JBQy9EQyxVQUFTOzs7Ozs7MEJBRVgsOERBQUNDO2dCQUFJNUgsS0FBS0k7Z0JBQVl5SCxXQUFVOzs7Ozs7OztBQUd0Qzs7QUFHRjlILGlCQUFpQitILFdBQVcsR0FBRztBQUUvQixpRUFBZS9ILGdCQUFnQkEsRUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxodWdvYVxcRGVza3RvcFxccmVwb3NcXHJlcG9zXFxtZXRhbW9kZWwyYmxvY2tseVxcZ2VuZXJhdGVkXFxib3dsaW5nX2FsbGV5LXZpc3VhbGNpXFxibG9ja2x5LXdvcmtzcGFjZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgU2NyaXB0IGZyb20gXCJuZXh0L3NjcmlwdFwiXG5pbXBvcnQgeyBFQ09SRV9CTE9DS1MsIEVDT1JFX1RPT0xCT1ggfSBmcm9tIFwiLi9lY29yZS1ibG9ja3NcIlxuaW1wb3J0IHsgRWNvcmVHZW5lcmF0b3IgfSBmcm9tIFwiLi9ibG9ja2x5LWNvZGUtZ2VuZXJhdG9yXCJcblxuLy8gRGVmaW5lIHByb3BzIGludGVyZmFjZVxuaW50ZXJmYWNlIEJsb2NrbHlXb3Jrc3BhY2VQcm9wcyB7XG4gIG9uQ2hhbmdlPzogKHhtbDogc3RyaW5nLCBjb2RlOiBzdHJpbmcpID0+IHZvaWRcbiAgaW5pdGlhbFhtbD86IHN0cmluZ1xuICBvbldvcmtzcGFjZUxvYWRlZD86ICh3b3Jrc3BhY2U6IGFueSkgPT4gdm9pZFxufVxuXG4vLyBEZWZpbmUgcmVmIGludGVyZmFjZSBmb3IgZXhwb3NlZCBtZXRob2RzXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NrbHlXb3Jrc3BhY2VSZWYge1xuICBzZXJpYWxpemVXb3Jrc3BhY2U6ICgpID0+IHN0cmluZ1xuICBsb2FkV29ya3NwYWNlOiAoanNvbkRhdGE6IHN0cmluZykgPT4gdm9pZFxuICBjbGVhcldvcmtzcGFjZTogKCkgPT4gdm9pZFxufVxuXG4vLyBEZWZhdWx0IHBpcGVsaW5lIGNvbmZpZ3VyYXRpb24gSlNPTlxuY29uc3QgREVGQVVMVF9QSVBFTElORV9KU09OID0ge1xuICBibG9ja3M6IHtcbiAgICBsYW5ndWFnZVZlcnNpb246IDAsXG4gICAgYmxvY2tzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWNvcmVfcGlwZWxpbmVcIixcbiAgICAgICAgaWQ6IFwieltJYnt8Om5LQV9YLSgoc35ZN3lcIixcbiAgICAgICAgeDogNzUsXG4gICAgICAgIHk6IDI0LFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICBBVFRSX05BTUU6IFwiZGVmYXVsdF9waXBlbGluZVwiLFxuICAgICAgICAgIEFUVFJfQ09OQ1VSUkVOVDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0czoge1xuICAgICAgICAgIENPTlRfV0hFTjoge1xuICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlY29yZV93aGVuXCIsXG4gICAgICAgICAgICAgIGlkOiBcIkRUYVJIYV9zSWpwSn1JL3l1YWYzXCIsXG4gICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgIEFUVFJfTkFNRTogXCJvbl93b3JrZmxvd19kaXNwYXRjaFwiLFxuICAgICAgICAgICAgICAgIEFUVFJfVFJJR0dFUjogXCJ3b3JrZmxvd19kaXNwYXRjaFwiLFxuICAgICAgICAgICAgICAgIEFUVFJfVElNRVI6IFwiXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgQ09OVF9KT0I6IHtcbiAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZWNvcmVfam9iXCIsXG4gICAgICAgICAgICAgIGlkOiBcImc5JSRYdngtNjZoLE9oL1BMIUtpXCIsXG4gICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgIEFUVFJfTkFNRTogXCJidWlsZFwiLFxuICAgICAgICAgICAgICAgIEFUVFJfQUxMT1dGQUlMVVJFOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBBVFRSX0RFU0NSSVBUSU9OOiBcIkJ1aWxkIGFuZCB0ZXN0IHRoZSBhcHBsaWNhdGlvblwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICBDT05UX1RPT0w6IHtcbiAgICAgICAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZWNvcmVfdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogXCJmVSFNWkZ8Xio0eXg5WmRnK1NYQVwiLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBBVFRSX05BTUU6IFwidWJ1bnR1LWxhdGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENPTlRfQ09NTUFORDoge1xuICAgICAgICAgICAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlY29yZV9jb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBcInh+cmRAN1hdaEwoRlFudHVZTzpgXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICAgIEFUVFJfTkFNRTogXCJzZXR1cFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBDT05UX1RPT0w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZWNvcmVfdG9vbF92YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJSKHY9SlhOYkE0WUJ0P3d4bW5QYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBVFRSX05BTUU6IFwibnBtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgQ09OVF9QQVJBTUVURVI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZWNvcmVfcGFyYW1ldGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIncoKm9zY1VAXmcjdF55RTVAQzVWXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFUVFJfUEFSQU1FVEVSOiBcImluc3RhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVjb3JlX3BhcmFtZXRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiTn5tJENNLCFUVlorUC40QWk7YUxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBVFRSX1BBUkFNRVRFUjogXCJpbnN0YWxsIC0tY2lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfSxcbn1cblxuLy8gQWRkIHRoZXNlIGNvbnN0YW50cyBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlLCBhZnRlciB0aGUgaW1wb3J0czpcbi8vIENvbnN0YW50cyBmb3IgbG9jYWxTdG9yYWdlIGtleXNcbmNvbnN0IFNUT1JBR0VfS0VZX1dPUktTUEFDRSA9IFwidmlzdWFsY2lfd29ya3NwYWNlXCJcblxuLy8gVGhpcyBjb21wb25lbnQgd2lsbCBiZSBsb2FkZWQgZHluYW1pY2FsbHkgdG8gYXZvaWQgU1NSIGlzc3VlcyB3aXRoIEJsb2NrbHlcbmNvbnN0IEJsb2NrbHlXb3Jrc3BhY2UgPSBmb3J3YXJkUmVmPEJsb2NrbHlXb3Jrc3BhY2VSZWYsIEJsb2NrbHlXb3Jrc3BhY2VQcm9wcz4oXG4gICh7IG9uQ2hhbmdlLCBpbml0aWFsWG1sLCBvbldvcmtzcGFjZUxvYWRlZCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBibG9ja2x5RGl2ID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICAgIGNvbnN0IFt3b3Jrc3BhY2UsIHNldFdvcmtzcGFjZV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpXG4gICAgY29uc3QgW2Jsb2NrbHlMb2FkZWQsIHNldEJsb2NrbHlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICAvLyBGdW5jdGlvbiB0byBsb2FkIHRoZSBkZWZhdWx0IHBpcGVsaW5lIHN0cnVjdHVyZVxuICAgIGNvbnN0IGxvYWREZWZhdWx0UGlwZWxpbmUgPSAod29ya3NwYWNlOiBhbnkpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSB3b3Jrc3BhY2UgZmlyc3RcbiAgICAgICAgd29ya3NwYWNlLmNsZWFyKClcblxuICAgICAgICAvLyBMb2FkIHRoZSBkZWZhdWx0IHBpcGVsaW5lIEpTT05cbiAgICAgICAgd2luZG93LkJsb2NrbHkuc2VyaWFsaXphdGlvbi53b3Jrc3BhY2VzLmxvYWQoREVGQVVMVF9QSVBFTElORV9KU09OLCB3b3Jrc3BhY2UpXG5cbiAgICAgICAgLy8gQ2VudGVyIHRoZSB3b3Jrc3BhY2Ugb24gdGhlIHBpcGVsaW5lIGJsb2NrXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IHdvcmtzcGFjZS5nZXRUb3BCbG9ja3MoZmFsc2UpXG4gICAgICAgIGlmIChibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHdvcmtzcGFjZS5jZW50ZXJPbkJsb2NrKGJsb2Nrc1swXS5pZClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBibG9ja3NbMF0gLy8gUmV0dXJuIHRoZSBwaXBlbGluZSBibG9ja1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgZGVmYXVsdCBwaXBlbGluZTpcIiwgZXJyb3IpXG5cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gY3JlYXRpbmcgYSBzaW1wbGUgcGlwZWxpbmUgaWYgbG9hZGluZyBmYWlsc1xuICAgICAgICBjb25zdCBwaXBlbGluZUJsb2NrID0gd29ya3NwYWNlLm5ld0Jsb2NrKFwiZWNvcmVfcGlwZWxpbmVcIilcbiAgICAgICAgcGlwZWxpbmVCbG9jay5zZXRGaWVsZFZhbHVlKFwiZGVmYXVsdF9waXBlbGluZVwiLCBcIkFUVFJfTkFNRVwiKVxuICAgICAgICBwaXBlbGluZUJsb2NrLmluaXRTdmcoKVxuICAgICAgICBwaXBlbGluZUJsb2NrLnJlbmRlcigpXG4gICAgICAgIHBpcGVsaW5lQmxvY2subW92ZUJ5KDUwLCA1MClcblxuICAgICAgICByZXR1cm4gcGlwZWxpbmVCbG9ja1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4cG9zZSBtZXRob2RzIHZpYSByZWZcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICAgIHNlcmlhbGl6ZVdvcmtzcGFjZTogKCkgPT4ge1xuICAgICAgICBpZiAoIXdvcmtzcGFjZSkgcmV0dXJuIFwiXCJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHdvcmtzcGFjZSB0byBKU09OXG4gICAgICAgICAgY29uc3QganNvbiA9IHdpbmRvdy5CbG9ja2x5LnNlcmlhbGl6YXRpb24ud29ya3NwYWNlcy5zYXZlKHdvcmtzcGFjZSlcbiAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMilcbiAgICAgICAgICAvLyBBbHNvIHNhdmUgZGlyZWN0bHkgdG8gbG9jYWxTdG9yYWdlIHRvIGVuc3VyZSBpdCdzIGFsd2F5cyBzYXZlZFxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZX1dPUktTUEFDRSwganNvblN0cmluZylcbiAgICAgICAgICByZXR1cm4ganNvblN0cmluZ1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZXJpYWxpemluZyB3b3Jrc3BhY2U6XCIsIGVycm9yKVxuICAgICAgICAgIHJldHVybiBcIlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsb2FkV29ya3NwYWNlOiAoanNvbkRhdGE6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIXdvcmtzcGFjZSkgcmV0dXJuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIHdvcmtzcGFjZSBmcm9tIEpTT04gZGF0YVwiKVxuICAgICAgICAgIC8vIENsZWFyIHRoZSB3b3Jrc3BhY2UgZmlyc3RcbiAgICAgICAgICB3b3Jrc3BhY2UuY2xlYXIoKVxuXG4gICAgICAgICAgLy8gUGFyc2UgdGhlIEpTT04gZGF0YVxuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGpzb25EYXRhKVxuXG4gICAgICAgICAgLy8gTG9hZCB0aGUgd29ya3NwYWNlIGZyb20gSlNPTlxuICAgICAgICAgIHdpbmRvdy5CbG9ja2x5LnNlcmlhbGl6YXRpb24ud29ya3NwYWNlcy5sb2FkKGpzb24sIHdvcmtzcGFjZSlcblxuICAgICAgICAgIC8vIENlbnRlciB0aGUgd29ya3NwYWNlIHZpZXdcbiAgICAgICAgICBjb25zdCBibG9ja3MgPSB3b3Jrc3BhY2UuZ2V0VG9wQmxvY2tzKGZhbHNlKVxuICAgICAgICAgIGlmIChibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd29ya3NwYWNlLmNlbnRlck9uQmxvY2soYmxvY2tzWzBdLmlkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyaWdnZXIgb25DaGFuZ2UgdG8gdXBkYXRlIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgeG1sID0gd2luZG93LkJsb2NrbHkuWG1sLndvcmtzcGFjZVRvRG9tKHdvcmtzcGFjZSlcbiAgICAgICAgICAgIGNvbnN0IHhtbFRleHQgPSB3aW5kb3cuQmxvY2tseS5YbWwuZG9tVG9UZXh0KHhtbClcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBFY29yZUdlbmVyYXRvci5nZW5lcmF0ZUNvZGUod29ya3NwYWNlKVxuICAgICAgICAgICAgb25DaGFuZ2UoeG1sVGV4dCwgY29kZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgd29ya3NwYWNlIGZyb20gSlNPTjpcIiwgZXJyb3IpXG4gICAgICAgICAgYWxlcnQoXCJFcnJvciBsb2FkaW5nIHdvcmtzcGFjZTogSW52YWxpZCBKU09OIGZvcm1hdCBvciBpbmNvbXBhdGlibGUgd29ya3NwYWNlIGRhdGFcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsZWFyV29ya3NwYWNlOiAoKSA9PiB7XG4gICAgICAgIGlmICghd29ya3NwYWNlKSByZXR1cm5cblxuICAgICAgICAvLyBKdXN0IGNsZWFyIHRoZSB3b3Jrc3BhY2UgY29tcGxldGVseSB3aXRob3V0IGxvYWRpbmcgdGhlIGRlZmF1bHQgcGlwZWxpbmVcbiAgICAgICAgd29ya3NwYWNlLmNsZWFyKClcblxuICAgICAgICAvLyBUcmlnZ2VyIG9uQ2hhbmdlIHRvIHVwZGF0ZSB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgY29uc3QgeG1sID0gd2luZG93LkJsb2NrbHkuWG1sLndvcmtzcGFjZVRvRG9tKHdvcmtzcGFjZSlcbiAgICAgICAgICBjb25zdCB4bWxUZXh0ID0gd2luZG93LkJsb2NrbHkuWG1sLmRvbVRvVGV4dCh4bWwpXG4gICAgICAgICAgY29uc3QgY29kZSA9IEVjb3JlR2VuZXJhdG9yLmdlbmVyYXRlQ29kZSh3b3Jrc3BhY2UpXG4gICAgICAgICAgb25DaGFuZ2UoeG1sVGV4dCwgY29kZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KSlcblxuICAgIC8vIEhhbmRsZSBzY3JpcHQgbG9hZCBldmVudFxuICAgIGNvbnN0IGhhbmRsZVNjcmlwdExvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkJsb2NrbHkgc2NyaXB0IGxvYWRlZFwiKVxuICAgICAgc2V0QmxvY2tseUxvYWRlZCh0cnVlKVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgQmxvY2tseSBhZnRlciB0aGUgc2NyaXB0IGhhcyBsb2FkZWRcbiAgICBjb25zdCBpbml0QmxvY2tseSA9ICgpID0+IHtcbiAgICAgIGlmICghYmxvY2tseURpdi5jdXJyZW50IHx8ICF3aW5kb3cuQmxvY2tseSkgcmV0dXJuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIEJsb2NrbHkuLi5cIiwgd2luZG93LkJsb2NrbHkpXG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgY3VzdG9tIGJsb2Nrc1xuICAgICAgICBFQ09SRV9CTE9DS1MuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgICAgICB3aW5kb3cuQmxvY2tseS5CbG9ja3NbYmxvY2sudHlwZV0gPSB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoaXMuanNvbkluaXQoYmxvY2spXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBDcmVhdGUgd29ya3NwYWNlIHdpdGggcmVzcG9uc2l2ZSBzZXR0aW5nc1xuICAgICAgICBjb25zdCBuZXdXb3Jrc3BhY2UgPSB3aW5kb3cuQmxvY2tseS5pbmplY3QoYmxvY2tseURpdi5jdXJyZW50LCB7XG4gICAgICAgICAgdG9vbGJveDogRUNPUkVfVE9PTEJPWCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgICAgIGxlbmd0aDogMyxcbiAgICAgICAgICAgIGNvbG91cjogXCIjY2NjXCIsXG4gICAgICAgICAgICBzbmFwOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgY29udHJvbHM6IHRydWUsXG4gICAgICAgICAgICB3aGVlbDogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXJ0U2NhbGU6IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gMC43IDogMS4wLCAvLyBTbWFsbGVyIHNjYWxlIG9uIG1vYmlsZVxuICAgICAgICAgICAgbWF4U2NhbGU6IDMsXG4gICAgICAgICAgICBtaW5TY2FsZTogMC4zLFxuICAgICAgICAgICAgc2NhbGVTcGVlZDogMS4yLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhc2hjYW46IHRydWUsXG4gICAgICAgICAgc2Nyb2xsYmFyczogdHJ1ZSxcbiAgICAgICAgICBzb3VuZHM6IGZhbHNlLCAvLyBEaXNhYmxlIHNvdW5kcyBmb3IgYmV0dGVyIG1vYmlsZSBleHBlcmllbmNlXG4gICAgICAgICAgbW92ZToge1xuICAgICAgICAgICAgc2Nyb2xsYmFyczogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWc6IHRydWUsXG4gICAgICAgICAgICB3aGVlbDogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIEVuYWJsZSBzdHJpY3QgdHlwZSBjaGVja2luZ1xuICAgICAgICAgIHR5cGVDaGVjazogdHJ1ZSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBBZGQgYXV0b21hdGljIGJsb2NrIGNyZWF0aW9uIGZvciBqb2IgYW5kIGNvbW1hbmQgYmxvY2tzXG4gICAgICAgIG5ld1dvcmtzcGFjZS5hZGRDaGFuZ2VMaXN0ZW5lcigoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIGJsb2NrIGNyZWF0aW9uIGV2ZW50c1xuICAgICAgICAgIGlmIChldmVudC50eXBlID09PSB3aW5kb3cuQmxvY2tseS5FdmVudHMuQkxPQ0tfQ1JFQVRFKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNyZWF0ZWQgYmxvY2tcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gbmV3V29ya3NwYWNlLmdldEJsb2NrQnlJZChldmVudC5ibG9ja0lkKVxuXG4gICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ld2x5IGNyZWF0ZWQgYmxvY2sgb3IgYSBjb3BpZWQgYmxvY2tcbiAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIGNvcGllZCBibG9jaywgaXQgd2lsbCBhbHJlYWR5IGhhdmUgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgY29uc3QgaXNOZXdseUNyZWF0ZWQgPSAhZXZlbnQuaWRzIHx8IGV2ZW50Lmlkcy5sZW5ndGggPD0gMVxuXG4gICAgICAgICAgICAgIC8vIElmIGEgam9iIGJsb2NrIGlzIGNyZWF0ZWQsIGF1dG9tYXRpY2FsbHkgYWRkIGEgdG9vbCBhbmQgY29tbWFuZCBibG9jayB0byBpdFxuICAgICAgICAgICAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJlY29yZV9qb2JcIikge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHRvb2wgYmxvY2sgdG8gdGhlIGpvYiBpZiB0aGUgdG9vbCBpbnB1dCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgIGlmICghYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfVE9PTFwiKSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgam9iIHRvb2wgYmxvY2tcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGpvYlRvb2xCbG9jayA9IG5ld1dvcmtzcGFjZS5uZXdCbG9jayhcImVjb3JlX3Rvb2xcIilcbiAgICAgICAgICAgICAgICAgIGpvYlRvb2xCbG9jay5pbml0U3ZnKClcbiAgICAgICAgICAgICAgICAgIGpvYlRvb2xCbG9jay5yZW5kZXIoKVxuXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBqb2IgdG9vbFxuICAgICAgICAgICAgICAgICAgam9iVG9vbEJsb2NrLnNldEZpZWxkVmFsdWUoXCJ1YnVudHUtbGF0ZXN0XCIsIFwiQVRUUl9OQU1FXCIpXG5cbiAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIHRvb2wgYmxvY2sgdG8gdGhlIGpvYiBibG9ja1xuICAgICAgICAgICAgICAgICAgY29uc3Qgam9iVG9vbENvbm5lY3Rpb24gPSBibG9jay5nZXRJbnB1dChcIkNPTlRfVE9PTFwiKS5jb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBqb2JUb29sQmxvY2tDb25uZWN0aW9uID0gam9iVG9vbEJsb2NrLnByZXZpb3VzQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgam9iVG9vbENvbm5lY3Rpb24uY29ubmVjdChqb2JUb29sQmxvY2tDb25uZWN0aW9uKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb21tYW5kIGlucHV0IGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5nZXRJbnB1dFRhcmdldEJsb2NrKFwiQ09OVF9DT01NQU5EXCIpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb21tYW5kIGJsb2NrXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kQmxvY2sgPSBuZXdXb3Jrc3BhY2UubmV3QmxvY2soXCJlY29yZV9jb21tYW5kXCIpXG4gICAgICAgICAgICAgICAgICBjb21tYW5kQmxvY2suaW5pdFN2ZygpXG4gICAgICAgICAgICAgICAgICBjb21tYW5kQmxvY2sucmVuZGVyKClcblxuICAgICAgICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBuYW1lIGZvciB0aGUgY29tbWFuZFxuICAgICAgICAgICAgICAgICAgY29tbWFuZEJsb2NrLnNldEZpZWxkVmFsdWUoXCJkZWZhdWx0X2NvbW1hbmRcIiwgXCJBVFRSX05BTUVcIilcblxuICAgICAgICAgICAgICAgICAgLy8gQ29ubmVjdCB0aGUgY29tbWFuZCBibG9jayB0byB0aGUgam9iIGJsb2NrXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kQ29ubmVjdGlvbiA9IGJsb2NrLmdldElucHV0KFwiQ09OVF9DT01NQU5EXCIpLmNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRCbG9ja0Nvbm5lY3Rpb24gPSBjb21tYW5kQmxvY2sucHJldmlvdXNDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb21tYW5kQ29ubmVjdGlvbi5jb25uZWN0KGNvbW1hbmRCbG9ja0Nvbm5lY3Rpb24pXG5cbiAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbW1hbmQgdG9vbCBibG9jayBmb3IgdGhlIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xCbG9jayA9IG5ld1dvcmtzcGFjZS5uZXdCbG9jayhcImVjb3JlX3Rvb2xfdmFsdWVcIilcbiAgICAgICAgICAgICAgICAgIHRvb2xCbG9jay5pbml0U3ZnKClcbiAgICAgICAgICAgICAgICAgIHRvb2xCbG9jay5yZW5kZXIoKVxuXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBjb21tYW5kIHRvb2xcbiAgICAgICAgICAgICAgICAgIHRvb2xCbG9jay5zZXRGaWVsZFZhbHVlKFwibnBtXCIsIFwiQVRUUl9OQU1FXCIpXG5cbiAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIHRvb2wgYmxvY2sgdG8gdGhlIGNvbW1hbmQgYmxvY2tcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDb25uZWN0aW9uID0gY29tbWFuZEJsb2NrLmdldElucHV0KFwiQ09OVF9UT09MXCIpLmNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xCbG9ja0Nvbm5lY3Rpb24gPSB0b29sQmxvY2sub3V0cHV0Q29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgdG9vbENvbm5lY3Rpb24uY29ubmVjdCh0b29sQmxvY2tDb25uZWN0aW9uKVxuXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwYXJhbWV0ZXIgYmxvY2sgZm9yIHRoZSBjb21tYW5kXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJCbG9jayA9IG5ld1dvcmtzcGFjZS5uZXdCbG9jayhcImVjb3JlX3BhcmFtZXRlclwiKVxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyQmxvY2suaW5pdFN2ZygpXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJCbG9jay5yZW5kZXIoKVxuXG4gICAgICAgICAgICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJCbG9jay5zZXRGaWVsZFZhbHVlKFwiaW5zdGFsbFwiLCBcIkFUVFJfUEFSQU1FVEVSXCIpXG5cbiAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIHBhcmFtZXRlciBibG9jayB0byB0aGUgY29tbWFuZCBibG9ja1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyQ29ubmVjdGlvbiA9IGNvbW1hbmRCbG9jay5nZXRJbnB1dChcIkNPTlRfUEFSQU1FVEVSXCIpLmNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlckJsb2NrQ29ubmVjdGlvbiA9IHBhcmFtZXRlckJsb2NrLnByZXZpb3VzQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyQ29ubmVjdGlvbi5jb25uZWN0KHBhcmFtZXRlckJsb2NrQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgYSBjb21tYW5kIGJsb2NrIGlzIGNyZWF0ZWQgbWFudWFsbHksIGF1dG9tYXRpY2FsbHkgYWRkIGEgdG9vbCBibG9jayB0byBpdFxuICAgICAgICAgICAgICBlbHNlIGlmIChibG9jay50eXBlID09PSBcImVjb3JlX2NvbW1hbmRcIiAmJiBpc05ld2x5Q3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGNoaWxkIGJsb2NrcyBpZiB0aGUgY29tbWFuZCBkb2Vzbid0IGFscmVhZHkgaGF2ZSB0aGVtXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgYmxvY2tzIHdoZW4gY29weWluZy9wYXN0aW5nXG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdG9vbCBpbnB1dCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgIGlmICghYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfVE9PTFwiKSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29tbWFuZCB0b29sIGJsb2NrXG4gICAgICAgICAgICAgICAgICBjb25zdCB0b29sQmxvY2sgPSBuZXdXb3Jrc3BhY2UubmV3QmxvY2soXCJlY29yZV90b29sX3ZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICB0b29sQmxvY2suaW5pdFN2ZygpXG4gICAgICAgICAgICAgICAgICB0b29sQmxvY2sucmVuZGVyKClcblxuICAgICAgICAgICAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBuYW1lIGZvciB0aGUgY29tbWFuZCB0b29sXG4gICAgICAgICAgICAgICAgICB0b29sQmxvY2suc2V0RmllbGRWYWx1ZShcIm5wbVwiLCBcIkFUVFJfTkFNRVwiKVxuXG4gICAgICAgICAgICAgICAgICAvLyBDb25uZWN0IHRoZSB0b29sIGJsb2NrIHRvIHRoZSBjb21tYW5kIGJsb2NrXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kQmxvY2sgPSBibG9jayAvLyBBc3NpZ24gdGhlIGJsb2NrIHRvIGNvbW1hbmRCbG9ja1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbENvbm5lY3Rpb24gPSBjb21tYW5kQmxvY2suZ2V0SW5wdXQoXCJDT05UX1RPT0xcIikuY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbEJsb2NrQ29ubmVjdGlvbiA9IHRvb2xCbG9jay5vdXRwdXRDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICB0b29sQ29ubmVjdGlvbi5jb25uZWN0KHRvb2xCbG9ja0Nvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhcmFtZXRlciBpbnB1dCBpcyBlbXB0eVxuICAgICAgICAgICAgICAgIGlmICghYmxvY2suZ2V0SW5wdXRUYXJnZXRCbG9jayhcIkNPTlRfUEFSQU1FVEVSXCIpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwYXJhbWV0ZXIgYmxvY2tcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlckJsb2NrID0gbmV3V29ya3NwYWNlLm5ld0Jsb2NrKFwiZWNvcmVfcGFyYW1ldGVyXCIpXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJCbG9jay5pbml0U3ZnKClcbiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckJsb2NrLnJlbmRlcigpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFNldCBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckJsb2NrLnNldEZpZWxkVmFsdWUoXCJpbnN0YWxsXCIsIFwiQVRUUl9QQVJBTUVURVJcIilcblxuICAgICAgICAgICAgICAgICAgLy8gQ29ubmVjdCB0aGUgcGFyYW1ldGVyIGJsb2NrIHRvIHRoZSBjb21tYW5kIGJsb2NrXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJDb25uZWN0aW9uID0gYmxvY2suZ2V0SW5wdXQoXCJDT05UX1BBUkFNRVRFUlwiKS5jb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJCbG9ja0Nvbm5lY3Rpb24gPSBwYXJhbWV0ZXJCbG9jay5wcmV2aW91c0Nvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckNvbm5lY3Rpb24uY29ubmVjdChwYXJhbWV0ZXJCbG9ja0Nvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBzYXZlZCB3b3Jrc3BhY2UgaW4gbG9jYWxTdG9yYWdlIGZpcnN0XG4gICAgICAgIGNvbnN0IHNhdmVkV29ya3NwYWNlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlfV09SS1NQQUNFKVxuICAgICAgICBpZiAoc2F2ZWRXb3Jrc3BhY2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBzYXZlZCB3b3Jrc3BhY2UgaW4gbG9jYWxTdG9yYWdlLCBsb2FkaW5nIGl0Li4uXCIpXG4gICAgICAgICAgICAvLyBQYXJzZSBhbmQgbG9hZCB0aGUgc2F2ZWQgd29ya3NwYWNlXG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShzYXZlZFdvcmtzcGFjZSlcbiAgICAgICAgICAgIHdpbmRvdy5CbG9ja2x5LnNlcmlhbGl6YXRpb24ud29ya3NwYWNlcy5sb2FkKGpzb24sIG5ld1dvcmtzcGFjZSlcblxuICAgICAgICAgICAgLy8gQ2VudGVyIHRoZSB3b3Jrc3BhY2Ugb24gdGhlIGZpcnN0IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBuZXdXb3Jrc3BhY2UuZ2V0VG9wQmxvY2tzKGZhbHNlKVxuICAgICAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG5ld1dvcmtzcGFjZS5jZW50ZXJPbkJsb2NrKGJsb2Nrc1swXS5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgd29ya3NwYWNlIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcilcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IgbG9hZGluZyBzYXZlZCB3b3Jrc3BhY2UsIGxvYWQgdGhlIGRlZmF1bHQgcGlwZWxpbmVcbiAgICAgICAgICAgIGxvYWREZWZhdWx0UGlwZWxpbmUobmV3V29ya3NwYWNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbml0aWFsWG1sKSB7XG4gICAgICAgICAgLy8gSWYgbm8gc2F2ZWQgd29ya3NwYWNlIGJ1dCBpbml0aWFsWG1sIGlzIHByb3ZpZGVkLCBsb2FkIHRoYXRcbiAgICAgICAgICBjb25zdCB4bWwgPSB3aW5kb3cuQmxvY2tseS5YbWwudGV4dFRvRG9tKGluaXRpYWxYbWwpXG4gICAgICAgICAgd2luZG93LkJsb2NrbHkuWG1sLmRvbVRvV29ya3NwYWNlKHhtbCwgbmV3V29ya3NwYWNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vIHNhdmVkIHdvcmtzcGFjZSBvciBpbml0aWFsWG1sLCBsb2FkIHRoZSBkZWZhdWx0IHBpcGVsaW5lXG4gICAgICAgICAgY29uc29sZS5sb2coXCJObyBzYXZlZCB3b3Jrc3BhY2UgZm91bmQsIGxvYWRpbmcgZGVmYXVsdCBwaXBlbGluZVwiKVxuICAgICAgICAgIGxvYWREZWZhdWx0UGlwZWxpbmUobmV3V29ya3NwYWNlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29kZSBnZW5lcmF0b3JcbiAgICAgICAgaWYgKHdpbmRvdy5CbG9ja2x5LkVjb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBFY29yZUdlbmVyYXRvci5pbml0KClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB1cCBjaGFuZ2UgbGlzdGVuZXIgd2l0aCBkZWJvdW5jZSB0byBwcmV2ZW50IHJhcGlkIHVwZGF0ZXNcbiAgICAgICAgbGV0IGNoYW5nZVRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgICAgbmV3V29ya3NwYWNlLmFkZENoYW5nZUxpc3RlbmVyKChldmVudDogYW55KSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHByb2Nlc3MgZXZlbnRzIHRoYXQgY2hhbmdlIHRoZSB3b3Jrc3BhY2UgY29udGVudFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSB3aW5kb3cuQmxvY2tseS5FdmVudHMuQkxPQ0tfTU9WRSB8fFxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSB3aW5kb3cuQmxvY2tseS5FdmVudHMuQkxPQ0tfQ0hBTkdFIHx8XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IHdpbmRvdy5CbG9ja2x5LkV2ZW50cy5CTE9DS19DUkVBVEUgfHxcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gd2luZG93LkJsb2NrbHkuRXZlbnRzLkJMT0NLX0RFTEVURVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIHRpbWVvdXRcbiAgICAgICAgICAgICAgaWYgKGNoYW5nZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2hhbmdlVGltZW91dClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFNldCBuZXcgdGltZW91dCB0byBkZWJvdW5jZSByYXBpZCBjaGFuZ2VzXG4gICAgICAgICAgICAgIGNoYW5nZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4bWwgPSB3aW5kb3cuQmxvY2tseS5YbWwud29ya3NwYWNlVG9Eb20obmV3V29ya3NwYWNlKVxuICAgICAgICAgICAgICAgIGNvbnN0IHhtbFRleHQgPSB3aW5kb3cuQmxvY2tseS5YbWwuZG9tVG9UZXh0KHhtbClcblxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGNvZGUgdXNpbmcgb3VyIGN1c3RvbSBnZW5lcmF0b3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gRWNvcmVHZW5lcmF0b3IuZ2VuZXJhdGVDb2RlKG5ld1dvcmtzcGFjZSlcblxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHhtbFRleHQsIGNvZGUpXG4gICAgICAgICAgICAgIH0sIDMwMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHdpbmRvdyByZXNpemVcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5CbG9ja2x5LnN2Z1Jlc2l6ZShuZXdXb3Jrc3BhY2UpXG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpXG5cbiAgICAgICAgLy8gU3RvcmUgd29ya3NwYWNlIGZvciBjbGVhbnVwXG4gICAgICAgIHNldFdvcmtzcGFjZShuZXdXb3Jrc3BhY2UpXG5cbiAgICAgICAgLy8gTm90aWZ5IHBhcmVudCB0aGF0IHdvcmtzcGFjZSBpcyBsb2FkZWRcbiAgICAgICAgaWYgKG9uV29ya3NwYWNlTG9hZGVkKSB7XG4gICAgICAgICAgb25Xb3Jrc3BhY2VMb2FkZWQobmV3V29ya3NwYWNlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpXG4gICAgICAgICAgaWYgKGNoYW5nZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjaGFuZ2VUaW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3V29ya3NwYWNlKSB7XG4gICAgICAgICAgICBuZXdXb3Jrc3BhY2UuZGlzcG9zZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIEJsb2NrbHk6XCIsIGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgQmxvY2tseSB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzIGFuZCB0aGUgc2NyaXB0IGlzIGxvYWRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tseUxvYWRlZCAmJiBibG9ja2x5RGl2LmN1cnJlbnQgJiYgIXdvcmtzcGFjZSkge1xuICAgICAgICBpbml0QmxvY2tseSgpXG4gICAgICB9XG4gICAgfSwgW2Jsb2NrbHlMb2FkZWQsIGJsb2NrbHlEaXYsIHdvcmtzcGFjZSwgaW5pdGlhbFhtbCwgb25DaGFuZ2UsIG9uV29ya3NwYWNlTG9hZGVkXSlcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICA8U2NyaXB0XG4gICAgICAgICAgc3JjPVwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9ibG9ja2x5QDExLjIuMi9ibG9ja2x5Lm1pbi5qc1wiXG4gICAgICAgICAgb25Mb2FkPXtoYW5kbGVTY3JpcHRMb2FkfVxuICAgICAgICAgIG9uRXJyb3I9eyhlKSA9PiBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBCbG9ja2x5IHNjcmlwdDpcIiwgZSl9XG4gICAgICAgICAgc3RyYXRlZ3k9XCJhZnRlckludGVyYWN0aXZlXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiByZWY9e2Jsb2NrbHlEaXZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgbWluLWgtWzMwMHB4XSBzbTptaW4taC1bNDAwcHhdXCIgLz5cbiAgICAgIDwvPlxuICAgIClcbiAgfSxcbilcblxuQmxvY2tseVdvcmtzcGFjZS5kaXNwbGF5TmFtZSA9IFwiQmxvY2tseVdvcmtzcGFjZVwiXG5cbmV4cG9ydCBkZWZhdWx0IEJsb2NrbHlXb3Jrc3BhY2VcblxuLy8gQWRkIEJsb2NrbHkgdG8gdGhlIHdpbmRvdyB0eXBlXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIEJsb2NrbHk6IGFueVxuICB9XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsIlNjcmlwdCIsIkVDT1JFX0JMT0NLUyIsIkVDT1JFX1RPT0xCT1giLCJFY29yZUdlbmVyYXRvciIsIkRFRkFVTFRfUElQRUxJTkVfSlNPTiIsImJsb2NrcyIsImxhbmd1YWdlVmVyc2lvbiIsInR5cGUiLCJpZCIsIngiLCJ5IiwiZmllbGRzIiwiQVRUUl9OQU1FIiwiQVRUUl9DT05DVVJSRU5UIiwiaW5wdXRzIiwiQ09OVF9XSEVOIiwiYmxvY2siLCJBVFRSX1RSSUdHRVIiLCJBVFRSX1RJTUVSIiwiQ09OVF9KT0IiLCJBVFRSX0FMTE9XRkFJTFVSRSIsIkFUVFJfREVTQ1JJUFRJT04iLCJDT05UX1RPT0wiLCJDT05UX0NPTU1BTkQiLCJDT05UX1BBUkFNRVRFUiIsIkFUVFJfUEFSQU1FVEVSIiwibmV4dCIsIlNUT1JBR0VfS0VZX1dPUktTUEFDRSIsIkJsb2NrbHlXb3Jrc3BhY2UiLCJyZWYiLCJvbkNoYW5nZSIsImluaXRpYWxYbWwiLCJvbldvcmtzcGFjZUxvYWRlZCIsImJsb2NrbHlEaXYiLCJ3b3Jrc3BhY2UiLCJzZXRXb3Jrc3BhY2UiLCJibG9ja2x5TG9hZGVkIiwic2V0QmxvY2tseUxvYWRlZCIsImxvYWREZWZhdWx0UGlwZWxpbmUiLCJjbGVhciIsIndpbmRvdyIsIkJsb2NrbHkiLCJzZXJpYWxpemF0aW9uIiwid29ya3NwYWNlcyIsImxvYWQiLCJnZXRUb3BCbG9ja3MiLCJsZW5ndGgiLCJjZW50ZXJPbkJsb2NrIiwiZXJyb3IiLCJjb25zb2xlIiwicGlwZWxpbmVCbG9jayIsIm5ld0Jsb2NrIiwic2V0RmllbGRWYWx1ZSIsImluaXRTdmciLCJyZW5kZXIiLCJtb3ZlQnkiLCJzZXJpYWxpemVXb3Jrc3BhY2UiLCJqc29uIiwic2F2ZSIsImpzb25TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImxvYWRXb3Jrc3BhY2UiLCJqc29uRGF0YSIsImxvZyIsInBhcnNlIiwieG1sIiwiWG1sIiwid29ya3NwYWNlVG9Eb20iLCJ4bWxUZXh0IiwiZG9tVG9UZXh0IiwiY29kZSIsImdlbmVyYXRlQ29kZSIsImFsZXJ0IiwiY2xlYXJXb3Jrc3BhY2UiLCJoYW5kbGVTY3JpcHRMb2FkIiwiaW5pdEJsb2NrbHkiLCJjdXJyZW50IiwiZm9yRWFjaCIsIkJsb2NrcyIsImluaXQiLCJqc29uSW5pdCIsIm5ld1dvcmtzcGFjZSIsImluamVjdCIsInRvb2xib3giLCJncmlkIiwic3BhY2luZyIsImNvbG91ciIsInNuYXAiLCJ6b29tIiwiY29udHJvbHMiLCJ3aGVlbCIsInN0YXJ0U2NhbGUiLCJpbm5lcldpZHRoIiwibWF4U2NhbGUiLCJtaW5TY2FsZSIsInNjYWxlU3BlZWQiLCJ0cmFzaGNhbiIsInNjcm9sbGJhcnMiLCJzb3VuZHMiLCJtb3ZlIiwiZHJhZyIsInR5cGVDaGVjayIsImFkZENoYW5nZUxpc3RlbmVyIiwiZXZlbnQiLCJFdmVudHMiLCJCTE9DS19DUkVBVEUiLCJnZXRCbG9ja0J5SWQiLCJibG9ja0lkIiwiaXNOZXdseUNyZWF0ZWQiLCJpZHMiLCJnZXRJbnB1dFRhcmdldEJsb2NrIiwiam9iVG9vbEJsb2NrIiwiam9iVG9vbENvbm5lY3Rpb24iLCJnZXRJbnB1dCIsImNvbm5lY3Rpb24iLCJqb2JUb29sQmxvY2tDb25uZWN0aW9uIiwicHJldmlvdXNDb25uZWN0aW9uIiwiY29ubmVjdCIsImNvbW1hbmRCbG9jayIsImNvbW1hbmRDb25uZWN0aW9uIiwiY29tbWFuZEJsb2NrQ29ubmVjdGlvbiIsInRvb2xCbG9jayIsInRvb2xDb25uZWN0aW9uIiwidG9vbEJsb2NrQ29ubmVjdGlvbiIsIm91dHB1dENvbm5lY3Rpb24iLCJwYXJhbWV0ZXJCbG9jayIsInBhcmFtZXRlckNvbm5lY3Rpb24iLCJwYXJhbWV0ZXJCbG9ja0Nvbm5lY3Rpb24iLCJzYXZlZFdvcmtzcGFjZSIsImdldEl0ZW0iLCJ0ZXh0VG9Eb20iLCJkb21Ub1dvcmtzcGFjZSIsIkVjb3JlIiwidW5kZWZpbmVkIiwiY2hhbmdlVGltZW91dCIsIkJMT0NLX01PVkUiLCJCTE9DS19DSEFOR0UiLCJCTE9DS19ERUxFVEUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiaGFuZGxlUmVzaXplIiwic3ZnUmVzaXplIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwb3NlIiwic3JjIiwib25Mb2FkIiwib25FcnJvciIsImUiLCJzdHJhdGVneSIsImRpdiIsImNsYXNzTmFtZSIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./blockly-workspace.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./ecore-blocks.tsx":
/*!**************************!*\
  !*** ./ecore-blocks.tsx ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ECORE_BLOCKS: () => (/* binding */ ECORE_BLOCKS),\n/* harmony export */   ECORE_TOOLBOX: () => (/* binding */ ECORE_TOOLBOX),\n/* harmony export */   registerEcoreBlocks: () => (/* binding */ registerEcoreBlocks)\n/* harmony export */ });\n// Custom Ecore model blocks for Blockly\n// Generated automatically from metamodel\nconst ECORE_BLOCKS = [\n    {\n        \"type\": \"League\",\n        \"message0\": \"League name %1 player %2\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"name\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"input_statement\",\n                \"name\": \"PLAYER\",\n                \"check\": [\n                    \"Player\"\n                ]\n            }\n        ],\n        \"colour\": 190,\n        \"previousStatement\": null,\n        \"nextStatement\": null\n    },\n    {\n        \"type\": \"Tournament\",\n        \"message0\": \"Tournament type %1 matchup %2\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"type\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"input_statement\",\n                \"name\": \"MATCHUP\",\n                \"check\": [\n                    \"Matchup\"\n                ]\n            }\n        ],\n        \"colour\": 185,\n        \"previousStatement\": null,\n        \"nextStatement\": null\n    },\n    {\n        \"type\": \"TournamentType\",\n        \"message0\": \"TournamentType Pro %1 Amateur %2\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"Pro\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"field_input\",\n                \"name\": \"Amateur\",\n                \"text\": \"\"\n            }\n        ],\n        \"colour\": 94,\n        \"output\": \"TournamentType\"\n    },\n    {\n        \"type\": \"Player\",\n        \"message0\": \"Player name %1 dateOfBirth %2 height %3 isPro %4\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"name\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"field_input\",\n                \"name\": \"dateOfBirth\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"field_input\",\n                \"name\": \"height\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"field_input\",\n                \"name\": \"isPro\",\n                \"text\": \"\"\n            }\n        ],\n        \"colour\": 235,\n        \"output\": \"Player\"\n    },\n    {\n        \"type\": \"Game\",\n        \"message0\": \"Game attribute %1 frame %2 player %3\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"attribute\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"input_statement\",\n                \"name\": \"FRAME\",\n                \"check\": [\n                    \"Frame\"\n                ]\n            },\n            {\n                \"type\": \"input_value\",\n                \"name\": \"PLAYER\",\n                \"check\": [\n                    \"Player\"\n                ]\n            }\n        ],\n        \"colour\": 162,\n        \"previousStatement\": null,\n        \"nextStatement\": null\n    },\n    {\n        \"type\": \"Matchup\",\n        \"message0\": \"Matchup attribute %1 game %2\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"attribute\",\n                \"text\": \"\"\n            },\n            {\n                \"type\": \"input_statement\",\n                \"name\": \"GAME\",\n                \"check\": [\n                    \"Game\"\n                ]\n            }\n        ],\n        \"colour\": 317,\n        \"previousStatement\": null,\n        \"nextStatement\": null\n    },\n    {\n        \"type\": \"Frame\",\n        \"message0\": \"Frame score %1\",\n        \"args0\": [\n            {\n                \"type\": \"field_input\",\n                \"name\": \"score\",\n                \"text\": \"\"\n            }\n        ],\n        \"colour\": 153,\n        \"output\": \"Frame\"\n    }\n];\nconst ECORE_TOOLBOX = {\n    kind: \"flyoutToolbox\",\n    contents: [\n        {\n            kind: \"block\",\n            type: \"League\"\n        },\n        {\n            kind: \"block\",\n            type: \"Tournament\"\n        },\n        {\n            kind: \"block\",\n            type: \"TournamentType\"\n        },\n        {\n            kind: \"block\",\n            type: \"Player\"\n        },\n        {\n            kind: \"block\",\n            type: \"Game\"\n        },\n        {\n            kind: \"block\",\n            type: \"Matchup\"\n        },\n        {\n            kind: \"block\",\n            type: \"Frame\"\n        }\n    ]\n};\n// Helper function to register blocks with Blockly\nfunction registerEcoreBlocks() {\n    ECORE_BLOCKS.forEach((blockDef)=>{\n        if (typeof Blockly !== 'undefined' && Blockly.Blocks) {\n            Blockly.Blocks[blockDef.type] = {\n                init: function() {\n                    this.jsonInit(blockDef);\n                }\n            };\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUMsTUFBTSxDQUFDRixTQUFTSCxJQUFJLENBQUMsR0FBRztnQkFDOUJNLE1BQU07b0JBQ0osSUFBSSxDQUFDQyxRQUFRLENBQUNKO2dCQUNoQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh1Z29hXFxEZXNrdG9wXFxyZXBvc1xccmVwb3NcXG1ldGFtb2RlbDJibG9ja2x5XFxnZW5lcmF0ZWRcXGJvd2xpbmdfYWxsZXktdmlzdWFsY2lcXGVjb3JlLWJsb2Nrcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VzdG9tIEVjb3JlIG1vZGVsIGJsb2NrcyBmb3IgQmxvY2tseVxyXG4vLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBmcm9tIG1ldGFtb2RlbFxyXG5cclxuZXhwb3J0IGNvbnN0IEVDT1JFX0JMT0NLUyA9IFtcclxuICB7XHJcbiAgXCJ0eXBlXCI6IFwiTGVhZ3VlXCIsXHJcbiAgXCJtZXNzYWdlMFwiOiBcIkxlYWd1ZSBuYW1lICUxIHBsYXllciAlMlwiLFxyXG4gIFwiYXJnczBcIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJuYW1lXCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJpbnB1dF9zdGF0ZW1lbnRcIixcclxuICAgICAgXCJuYW1lXCI6IFwiUExBWUVSXCIsXHJcbiAgICAgIFwiY2hlY2tcIjogW1xyXG4gICAgICAgIFwiUGxheWVyXCJcclxuICAgICAgXVxyXG4gICAgfVxyXG4gIF0sXHJcbiAgXCJjb2xvdXJcIjogMTkwLFxyXG4gIFwicHJldmlvdXNTdGF0ZW1lbnRcIjogbnVsbCxcclxuICBcIm5leHRTdGF0ZW1lbnRcIjogbnVsbFxyXG59LFxyXG4gIHtcclxuICBcInR5cGVcIjogXCJUb3VybmFtZW50XCIsXHJcbiAgXCJtZXNzYWdlMFwiOiBcIlRvdXJuYW1lbnQgdHlwZSAlMSBtYXRjaHVwICUyXCIsXHJcbiAgXCJhcmdzMFwiOiBbXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcImZpZWxkX2lucHV0XCIsXHJcbiAgICAgIFwibmFtZVwiOiBcInR5cGVcIixcclxuICAgICAgXCJ0ZXh0XCI6IFwiXCJcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcImlucHV0X3N0YXRlbWVudFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJNQVRDSFVQXCIsXHJcbiAgICAgIFwiY2hlY2tcIjogW1xyXG4gICAgICAgIFwiTWF0Y2h1cFwiXHJcbiAgICAgIF1cclxuICAgIH1cclxuICBdLFxyXG4gIFwiY29sb3VyXCI6IDE4NSxcclxuICBcInByZXZpb3VzU3RhdGVtZW50XCI6IG51bGwsXHJcbiAgXCJuZXh0U3RhdGVtZW50XCI6IG51bGxcclxufSxcclxuICB7XHJcbiAgXCJ0eXBlXCI6IFwiVG91cm5hbWVudFR5cGVcIixcclxuICBcIm1lc3NhZ2UwXCI6IFwiVG91cm5hbWVudFR5cGUgUHJvICUxIEFtYXRldXIgJTJcIixcclxuICBcImFyZ3MwXCI6IFtcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmllbGRfaW5wdXRcIixcclxuICAgICAgXCJuYW1lXCI6IFwiUHJvXCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJBbWF0ZXVyXCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9XHJcbiAgXSxcclxuICBcImNvbG91clwiOiA5NCxcclxuICBcIm91dHB1dFwiOiBcIlRvdXJuYW1lbnRUeXBlXCJcclxufSxcclxuICB7XHJcbiAgXCJ0eXBlXCI6IFwiUGxheWVyXCIsXHJcbiAgXCJtZXNzYWdlMFwiOiBcIlBsYXllciBuYW1lICUxIGRhdGVPZkJpcnRoICUyIGhlaWdodCAlMyBpc1BybyAlNFwiLFxyXG4gIFwiYXJnczBcIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJuYW1lXCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJkYXRlT2ZCaXJ0aFwiLFxyXG4gICAgICBcInRleHRcIjogXCJcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmllbGRfaW5wdXRcIixcclxuICAgICAgXCJuYW1lXCI6IFwiaGVpZ2h0XCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJpc1Byb1wiLFxyXG4gICAgICBcInRleHRcIjogXCJcIlxyXG4gICAgfVxyXG4gIF0sXHJcbiAgXCJjb2xvdXJcIjogMjM1LFxyXG4gIFwib3V0cHV0XCI6IFwiUGxheWVyXCJcclxufSxcclxuICB7XHJcbiAgXCJ0eXBlXCI6IFwiR2FtZVwiLFxyXG4gIFwibWVzc2FnZTBcIjogXCJHYW1lIGF0dHJpYnV0ZSAlMSBmcmFtZSAlMiBwbGF5ZXIgJTNcIixcclxuICBcImFyZ3MwXCI6IFtcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiZmllbGRfaW5wdXRcIixcclxuICAgICAgXCJuYW1lXCI6IFwiYXR0cmlidXRlXCIsXHJcbiAgICAgIFwidGV4dFwiOiBcIlwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJpbnB1dF9zdGF0ZW1lbnRcIixcclxuICAgICAgXCJuYW1lXCI6IFwiRlJBTUVcIixcclxuICAgICAgXCJjaGVja1wiOiBbXHJcbiAgICAgICAgXCJGcmFtZVwiXHJcbiAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcImlucHV0X3ZhbHVlXCIsXHJcbiAgICAgIFwibmFtZVwiOiBcIlBMQVlFUlwiLFxyXG4gICAgICBcImNoZWNrXCI6IFtcclxuICAgICAgICBcIlBsYXllclwiXHJcbiAgICAgIF1cclxuICAgIH1cclxuICBdLFxyXG4gIFwiY29sb3VyXCI6IDE2MixcclxuICBcInByZXZpb3VzU3RhdGVtZW50XCI6IG51bGwsXHJcbiAgXCJuZXh0U3RhdGVtZW50XCI6IG51bGxcclxufSxcclxuICB7XHJcbiAgXCJ0eXBlXCI6IFwiTWF0Y2h1cFwiLFxyXG4gIFwibWVzc2FnZTBcIjogXCJNYXRjaHVwIGF0dHJpYnV0ZSAlMSBnYW1lICUyXCIsXHJcbiAgXCJhcmdzMFwiOiBbXHJcbiAgICB7XHJcbiAgICAgIFwidHlwZVwiOiBcImZpZWxkX2lucHV0XCIsXHJcbiAgICAgIFwibmFtZVwiOiBcImF0dHJpYnV0ZVwiLFxyXG4gICAgICBcInRleHRcIjogXCJcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJ0eXBlXCI6IFwiaW5wdXRfc3RhdGVtZW50XCIsXHJcbiAgICAgIFwibmFtZVwiOiBcIkdBTUVcIixcclxuICAgICAgXCJjaGVja1wiOiBbXHJcbiAgICAgICAgXCJHYW1lXCJcclxuICAgICAgXVxyXG4gICAgfVxyXG4gIF0sXHJcbiAgXCJjb2xvdXJcIjogMzE3LFxyXG4gIFwicHJldmlvdXNTdGF0ZW1lbnRcIjogbnVsbCxcclxuICBcIm5leHRTdGF0ZW1lbnRcIjogbnVsbFxyXG59LFxyXG4gIHtcclxuICBcInR5cGVcIjogXCJGcmFtZVwiLFxyXG4gIFwibWVzc2FnZTBcIjogXCJGcmFtZSBzY29yZSAlMVwiLFxyXG4gIFwiYXJnczBcIjogW1xyXG4gICAge1xyXG4gICAgICBcInR5cGVcIjogXCJmaWVsZF9pbnB1dFwiLFxyXG4gICAgICBcIm5hbWVcIjogXCJzY29yZVwiLFxyXG4gICAgICBcInRleHRcIjogXCJcIlxyXG4gICAgfVxyXG4gIF0sXHJcbiAgXCJjb2xvdXJcIjogMTUzLFxyXG4gIFwib3V0cHV0XCI6IFwiRnJhbWVcIlxyXG59LFxyXG5dIGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IEVDT1JFX1RPT0xCT1ggPSB7XHJcbiAga2luZDogXCJmbHlvdXRUb29sYm94XCIgYXMgY29uc3QsXHJcbiAgY29udGVudHM6IFtcclxuICAgIHtraW5kOiBcImJsb2NrXCIgYXMgY29uc3QsIHR5cGU6IFwiTGVhZ3VlXCJ9LFxyXG4gICAge2tpbmQ6IFwiYmxvY2tcIiBhcyBjb25zdCwgdHlwZTogXCJUb3VybmFtZW50XCJ9LFxyXG4gICAge2tpbmQ6IFwiYmxvY2tcIiBhcyBjb25zdCwgdHlwZTogXCJUb3VybmFtZW50VHlwZVwifSxcclxuICAgIHtraW5kOiBcImJsb2NrXCIgYXMgY29uc3QsIHR5cGU6IFwiUGxheWVyXCJ9LFxyXG4gICAge2tpbmQ6IFwiYmxvY2tcIiBhcyBjb25zdCwgdHlwZTogXCJHYW1lXCJ9LFxyXG4gICAge2tpbmQ6IFwiYmxvY2tcIiBhcyBjb25zdCwgdHlwZTogXCJNYXRjaHVwXCJ9LFxyXG4gICAge2tpbmQ6IFwiYmxvY2tcIiBhcyBjb25zdCwgdHlwZTogXCJGcmFtZVwifSxcclxuICBdLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGJsb2NrcyB3aXRoIEJsb2NrbHlcclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRWNvcmVCbG9ja3MoKSB7XHJcbiAgRUNPUkVfQkxPQ0tTLmZvckVhY2goKGJsb2NrRGVmKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIEJsb2NrbHkgIT09ICd1bmRlZmluZWQnICYmIEJsb2NrbHkuQmxvY2tzKSB7XHJcbiAgICAgIEJsb2NrbHkuQmxvY2tzW2Jsb2NrRGVmLnR5cGVdID0ge1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGhpcy5qc29uSW5pdChibG9ja0RlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJFQ09SRV9CTE9DS1MiLCJFQ09SRV9UT09MQk9YIiwia2luZCIsImNvbnRlbnRzIiwidHlwZSIsInJlZ2lzdGVyRWNvcmVCbG9ja3MiLCJmb3JFYWNoIiwiYmxvY2tEZWYiLCJCbG9ja2x5IiwiQmxvY2tzIiwiaW5pdCIsImpzb25Jbml0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./ecore-blocks.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/script.js":
/*!**********************************************!*\
  !*** ./node_modules/next/dist/api/script.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _client_script__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/script */ \"(app-pages-browser)/./node_modules/next/dist/client/script.js\");\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_script__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_script__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_script__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDVjs7QUFFakMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHVnb2FcXERlc2t0b3BcXHJlcG9zXFxyZXBvc1xcbWV0YW1vZGVsMmJsb2NrbHlcXGdlbmVyYXRlZFxcYm93bGluZ19hbGxleS12aXN1YWxjaVxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxhcGlcXHNjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi4vY2xpZW50L3NjcmlwdCc7XG5leHBvcnQgKiBmcm9tICcuLi9jbGllbnQvc2NyaXB0JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyaXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLGtCQUFrQjtlQUFsQkE7O0lBaEJBQyxtQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDVixPQUFPQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUEsQ0FBSTtZQUM1QztRQUNGO0lBQ0YsR0FBRztBQUNMO0FBRUssTUFBTU4scUJBQ1YsT0FBT0UsU0FBUyxlQUNmQSxLQUFLRixrQkFBa0IsSUFDdkJFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQy9CLFNBQVVVLEVBQVU7SUFDbEIsT0FBT0MsYUFBYUQ7QUFDdEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHVnb2FcXERlc2t0b3BcXHJlcG9zXFxyZXBvc1xcbWV0YW1vZGVsMmJsb2NrbHlcXHNyY1xcY2xpZW50XFxyZXF1ZXN0LWlkbGUtY2FsbGJhY2sudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmXG4gICAgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSkgfHxcbiAgZnVuY3Rpb24gKGNiOiBJZGxlUmVxdWVzdENhbGxiYWNrKTogbnVtYmVyIHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYih7XG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sIDEpXG4gIH1cblxuZXhwb3J0IGNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmLmNhbmNlbElkbGVDYWxsYmFjayAmJlxuICAgIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSkgfHxcbiAgZnVuY3Rpb24gKGlkOiBudW1iZXIpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKVxuICB9XG4iXSwibmFtZXMiOlsiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJiaW5kIiwid2luZG93IiwiY2IiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJzZXRUaW1lb3V0IiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNYXRoIiwibWF4IiwiaWQiLCJjbGVhclRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    handleClientScriptLoad: function() {\n        return handleClientScriptLoad;\n    },\n    initScriptLoader: function() {\n        return initScriptLoader;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _setattributesfromprops = __webpack_require__(/*! ./set-attributes-from-props */ \"(app-pages-browser)/./node_modules/next/dist/client/set-attributes-from-props.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst insertStylesheets = (stylesheets)=>{\n    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n    //\n    // Using ReactDOM.preinit to feature detect appDir and inject styles\n    // Stylesheets might have already been loaded if initialized with Script component\n    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n    if (_reactdom.default.preinit) {\n        stylesheets.forEach((stylesheet)=>{\n            _reactdom.default.preinit(stylesheet, {\n                as: 'style'\n            });\n        });\n        return;\n    }\n    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n    //\n    // We use this function to load styles when appdir is not detected\n    // TODO: Use React float APIs to load styles once available for pages dir\n    if (true) {\n        let head = document.head;\n        stylesheets.forEach((stylesheet)=>{\n            let link = document.createElement('link');\n            link.type = 'text/css';\n            link.rel = 'stylesheet';\n            link.href = stylesheet;\n            head.appendChild(link);\n        });\n    }\n};\nconst loadScript = (props)=>{\n    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = '', strategy = 'afterInteractive', onError, stylesheets } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement('script');\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener('load', function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener('error', function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n        el.innerHTML = dangerouslySetInnerHTML.__html || '';\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n    if (strategy === 'worker') {\n        el.setAttribute('type', 'text/partytown');\n    }\n    el.setAttribute('data-nscript', strategy);\n    // Load styles associated with this script\n    if (stylesheets) {\n        insertStylesheets(stylesheets);\n    }\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy = 'afterInteractive' } = props;\n    if (strategy === 'lazyOnload') {\n        window.addEventListener('load', ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === 'complete') {\n        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n    } else {\n        window.addEventListener('load', ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute('src');\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\n/**\n * Load a third-party scripts in an optimized way.\n *\n * Read more: [Next.js Docs: `next/script`](https://nextjs.org/docs/app/api-reference/components/script)\n */ function Script(props) {\n    const { id, src = '', onLoad = ()=>{}, onReady = null, strategy = 'afterInteractive', onError, stylesheets, ...restProps } = props;\n    // Context is available only during SSR\n    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === 'afterInteractive') {\n                loadScript(props);\n            } else if (strategy === 'lazyOnload') {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === 'beforeInteractive' || strategy === 'worker') {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                {\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError,\n                    ...restProps\n                }\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n        // For other strategies injecting here ensures correct stylesheet order\n        // ReactDOM.preinit handles loading the styles in the correct order,\n        // also ensures the stylesheet is loaded only once and in a consistent manner\n        //\n        // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n        if (stylesheets) {\n            stylesheets.forEach((styleSrc)=>{\n                _reactdom.default.preinit(styleSrc, {\n                    as: 'style'\n                });\n            });\n        }\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === 'beforeInteractive') {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            0,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            } else {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: 'script',\n                    integrity: restProps.integrity,\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                } : {\n                    as: 'script',\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                });\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            src,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            }\n        } else if (strategy === 'afterInteractive') {\n            if (src) {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: 'script',\n                    integrity: restProps.integrity,\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                } : {\n                    as: 'script',\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                });\n            }\n        }\n    }\n    return null;\n}\n_c = Script;\nObject.defineProperty(Script, '__nextScript', {\n    value: true\n});\nconst _default = Script;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5WEEsT0FBcUI7ZUFBckI7O0lBN05nQkEsc0JBQXNCO2VBQXRCQTs7SUFnQ0FDLGdCQUFnQjtlQUFoQkE7Ozs7OzsrRUExTEs7NkVBQzBDOzZEQUU1QjtvREFDSTtpREFDSDtBQUVwQyxNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLE1BQU1DLFlBQVksSUFBSUM7QUFpQnRCLE1BQU1DLG9CQUFvQixDQUFDQztJQUN6QixpR0FBaUc7SUFDakcsRUFBRTtJQUNGLG9FQUFvRTtJQUNwRSxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDZFQUE2RTtJQUM3RSxJQUFJQyxVQUFBQSxPQUFRLENBQUNDLE9BQU8sRUFBRTtRQUNwQkYsWUFBWUcsT0FBTyxDQUFDLENBQUNDO1lBQ25CSCxVQUFBQSxPQUFRLENBQUNDLE9BQU8sQ0FBQ0UsWUFBWTtnQkFBRUMsSUFBSTtZQUFRO1FBQzdDO1FBRUE7SUFDRjtJQUVBLGdHQUFnRztJQUNoRyxFQUFFO0lBQ0Ysa0VBQWtFO0lBQ2xFLHlFQUF5RTtJQUN6RSxJQUFJLElBQTZCLEVBQUU7UUFDakMsSUFBSUUsT0FBT0MsU0FBU0QsSUFBSTtRQUN4QlAsWUFBWUcsT0FBTyxDQUFDLENBQUNDO1lBQ25CLElBQUlLLE9BQU9ELFNBQVNFLGFBQWEsQ0FBQztZQUVsQ0QsS0FBS0UsSUFBSSxHQUFHO1lBQ1pGLEtBQUtHLEdBQUcsR0FBRztZQUNYSCxLQUFLSSxJQUFJLEdBQUdUO1lBRVpHLEtBQUtPLFdBQVcsQ0FBQ0w7UUFDbkI7SUFDRjtBQUNGO0FBRUEsTUFBTU0sYUFBYSxDQUFDQztJQUNsQixNQUFNLEVBQ0pDLEdBQUcsRUFDSEMsRUFBRSxFQUNGQyxTQUFTLEtBQU8sQ0FBQyxFQUNqQkMsVUFBVSxJQUFJLEVBQ2RDLHVCQUF1QixFQUN2QkMsV0FBVyxFQUFFLEVBQ2JDLFdBQVcs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RTtRQUNGO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7S0EvS1NuQjtBQWlMVG9CLE9BQU9DLGNBQWMsQ0FBQ3JCLFFBQVEsZ0JBQWdCO0lBQUVzQixPQUFPO0FBQUs7TUFFNUQsV0FBZXRCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGh1Z29hXFxEZXNrdG9wXFxyZXBvc1xccmVwb3NcXG1ldGFtb2RlbDJibG9ja2x5XFxzcmNcXGNsaWVudFxcc2NyaXB0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZUNvbnRleHQsIHVzZVJlZiwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgU2NyaXB0SFRNTEF0dHJpYnV0ZXMgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIH0gZnJvbSAnLi9zZXQtYXR0cmlidXRlcy1mcm9tLXByb3BzJ1xuaW1wb3J0IHsgcmVxdWVzdElkbGVDYWxsYmFjayB9IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG5jb25zdCBTY3JpcHRDYWNoZSA9IG5ldyBNYXAoKVxuY29uc3QgTG9hZENhY2hlID0gbmV3IFNldCgpXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NyaXB0UHJvcHMgZXh0ZW5kcyBTY3JpcHRIVE1MQXR0cmlidXRlczxIVE1MU2NyaXB0RWxlbWVudD4ge1xuICBzdHJhdGVneT86ICdhZnRlckludGVyYWN0aXZlJyB8ICdsYXp5T25sb2FkJyB8ICdiZWZvcmVJbnRlcmFjdGl2ZScgfCAnd29ya2VyJ1xuICBpZD86IHN0cmluZ1xuICBvbkxvYWQ/OiAoZTogYW55KSA9PiB2b2lkXG4gIG9uUmVhZHk/OiAoKSA9PiB2b2lkIHwgbnVsbFxuICBvbkVycm9yPzogKGU6IGFueSkgPT4gdm9pZFxuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICBzdHlsZXNoZWV0cz86IHN0cmluZ1tdXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBTY3JpcHRQcm9wc2AgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgUHJvcHMgPSBTY3JpcHRQcm9wc1xuXG5jb25zdCBpbnNlcnRTdHlsZXNoZWV0cyA9IChzdHlsZXNoZWV0czogc3RyaW5nW10pID0+IHtcbiAgLy8gQ2FzZSAxOiBTdHlsZXMgZm9yIGFmdGVySW50ZXJhY3RpdmUvbGF6eU9ubG9hZCB3aXRoIGFwcERpciBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAvL1xuICAvLyBVc2luZyBSZWFjdERPTS5wcmVpbml0IHRvIGZlYXR1cmUgZGV0ZWN0IGFwcERpciBhbmQgaW5qZWN0IHN0eWxlc1xuICAvLyBTdHlsZXNoZWV0cyBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQgaWYgaW5pdGlhbGl6ZWQgd2l0aCBTY3JpcHQgY29tcG9uZW50XG4gIC8vIFJlLWluamVjdCBzdHlsZXMgaGVyZSB0byBoYW5kbGUgc2NyaXB0cyBsb2FkZWQgdmlhIGhhbmRsZUNsaWVudFNjcmlwdExvYWRcbiAgLy8gUmVhY3RET00ucHJlaW5pdCBoYW5kbGVzIGRlZHVwIGFuZCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGxvYWRlZCBvbmx5IG9uY2VcbiAgaWYgKFJlYWN0RE9NLnByZWluaXQpIHtcbiAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0OiBzdHJpbmcpID0+IHtcbiAgICAgIFJlYWN0RE9NLnByZWluaXQoc3R5bGVzaGVldCwgeyBhczogJ3N0eWxlJyB9KVxuICAgIH0pXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIENhc2UgMjogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBwYWdlcyBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAvL1xuICAvLyBXZSB1c2UgdGhpcyBmdW5jdGlvbiB0byBsb2FkIHN0eWxlcyB3aGVuIGFwcGRpciBpcyBub3QgZGV0ZWN0ZWRcbiAgLy8gVE9ETzogVXNlIFJlYWN0IGZsb2F0IEFQSXMgdG8gbG9hZCBzdHlsZXMgb25jZSBhdmFpbGFibGUgZm9yIHBhZ2VzIGRpclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgaGVhZCA9IGRvY3VtZW50LmhlYWRcbiAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0OiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG5cbiAgICAgIGxpbmsudHlwZSA9ICd0ZXh0L2NzcydcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnXG4gICAgICBsaW5rLmhyZWYgPSBzdHlsZXNoZWV0XG5cbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGxvYWRTY3JpcHQgPSAocHJvcHM6IFNjcmlwdFByb3BzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHtcbiAgICBzcmMsXG4gICAgaWQsXG4gICAgb25Mb2FkID0gKCkgPT4ge30sXG4gICAgb25SZWFkeSA9IG51bGwsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsXG4gICAgY2hpbGRyZW4gPSAnJyxcbiAgICBzdHJhdGVneSA9ICdhZnRlckludGVyYWN0aXZlJyxcbiAgICBvbkVycm9yLFxuICAgIHN0eWxlc2hlZXRzLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBjYWNoZUtleSA9IGlkIHx8IHNyY1xuXG4gIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWRcbiAgaWYgKGNhY2hlS2V5ICYmIExvYWRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBDb250ZW50cyBvZiB0aGlzIHNjcmlwdCBhcmUgYWxyZWFkeSBsb2FkaW5nL2xvYWRlZFxuICBpZiAoU2NyaXB0Q2FjaGUuaGFzKHNyYykpIHtcbiAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KVxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgbXVsdGlwbGUgYG5leHQvc2NyaXB0YCBjb21wb25lbnRzIGFsbCBoYXZlIHNhbWUgXCJzcmNcIiwgYnV0IGhhcyBkaWZmZXJlbnQgXCJvbkxvYWRcIlxuICAgIC8vIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoZSBzYW1lIHJlbW90ZSBzY3JpcHQgd2lsbCBvbmx5IGxvYWQgb25jZSwgYnV0IFwib25Mb2FkXCIgYXJlIGV4ZWN1dGVkIGluIG9yZGVyXG4gICAgU2NyaXB0Q2FjaGUuZ2V0KHNyYykudGhlbihvbkxvYWQsIG9uRXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiogRXhlY3V0ZSBhZnRlciB0aGUgc2NyaXB0IGZpcnN0IGxvYWRlZCAqL1xuICBjb25zdCBhZnRlckxvYWQgPSAoKSA9PiB7XG4gICAgLy8gUnVuIG9uUmVhZHkgZm9yIHRoZSBmaXJzdCB0aW1lIGFmdGVyIGxvYWQgZXZlbnRcbiAgICBpZiAob25SZWFkeSkge1xuICAgICAgb25SZWFkeSgpXG4gICAgfVxuICAgIC8vIGFkZCBjYWNoZUtleSB0byBMb2FkQ2FjaGUgd2hlbiBsb2FkIHN1Y2Nlc3NmdWxseVxuICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpXG4gIH1cblxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgY29uc3QgbG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXNvbHZlKClcbiAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgb25Mb2FkLmNhbGwodGhpcywgZSlcbiAgICAgIH1cbiAgICAgIGFmdGVyTG9hZCgpXG4gICAgfSlcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZWplY3QoZSlcbiAgICB9KVxuICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBvbkVycm9yKGUpXG4gICAgfVxuICB9KVxuXG4gIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgIC8vIENhc3Rpbmcgc2luY2UgbGliLmRvbS5kLnRzIGRvZXNuJ3QgaGF2ZSBUcnVzdGVkSFRNTCB5ZXQuXG4gICAgZWwuaW5uZXJIVE1MID0gKGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCBhcyBzdHJpbmcpIHx8ICcnXG5cbiAgICBhZnRlckxvYWQoKVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgZWwudGV4dENvbnRlbnQgPVxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICA/IGNoaWxkcmVuLmpvaW4oJycpXG4gICAgICAgICAgOiAnJ1xuXG4gICAgYWZ0ZXJMb2FkKClcbiAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICBlbC5zcmMgPSBzcmNcbiAgICAvLyBkbyBub3QgYWRkIGNhY2hlS2V5IGludG8gTG9hZENhY2hlIGZvciByZW1vdGUgc2NyaXB0IGhlcmVcbiAgICAvLyBjYWNoZUtleSB3aWxsIGJlIGFkZGVkIHRvIExvYWRDYWNoZSB3aGVuIGl0IGlzIGFjdHVhbGx5IGxvYWRlZCAoc2VlIGxvYWRQcm9taXNlIGFib3ZlKVxuXG4gICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpXG4gIH1cblxuICBzZXRBdHRyaWJ1dGVzRnJvbVByb3BzKGVsLCBwcm9wcylcblxuICBpZiAoc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvcGFydHl0b3duJylcbiAgfVxuXG4gIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1uc2NyaXB0Jywgc3RyYXRlZ3kpXG5cbiAgLy8gTG9hZCBzdHlsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NyaXB0XG4gIGlmIChzdHlsZXNoZWV0cykge1xuICAgIGluc2VydFN0eWxlc2hlZXRzKHN0eWxlc2hlZXRzKVxuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNsaWVudFNjcmlwdExvYWQocHJvcHM6IFNjcmlwdFByb3BzKSB7XG4gIGNvbnN0IHsgc3RyYXRlZ3kgPSAnYWZ0ZXJJbnRlcmFjdGl2ZScgfSA9IHByb3BzXG4gIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGxvYWRTY3JpcHQocHJvcHMpKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgbG9hZFNjcmlwdChwcm9wcylcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkTGF6eVNjcmlwdChwcm9wczogU2NyaXB0UHJvcHMpIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGxvYWRTY3JpcHQocHJvcHMpKVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBsb2FkU2NyaXB0KHByb3BzKSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpIHtcbiAgY29uc3Qgc2NyaXB0cyA9IFtcbiAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcbiAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlUGFnZVJlbmRlclwiXScpLFxuICBdXG4gIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBzY3JpcHQuaWQgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNjcmlwdExvYWRlcihzY3JpcHRMb2FkZXJJdGVtczogU2NyaXB0UHJvcHNbXSkge1xuICBzY3JpcHRMb2FkZXJJdGVtcy5mb3JFYWNoKGhhbmRsZUNsaWVudFNjcmlwdExvYWQpXG4gIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpXG59XG5cbi8qKlxuICogTG9hZCBhIHRoaXJkLXBhcnR5IHNjcmlwdHMgaW4gYW4gb3B0aW1pemVkIHdheS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBuZXh0L3NjcmlwdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvc2NyaXB0KVxuICovXG5mdW5jdGlvbiBTY3JpcHQocHJvcHM6IFNjcmlwdFByb3BzKTogSlNYLkVsZW1lbnQgfCBudWxsIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIHNyYyA9ICcnLFxuICAgIG9uTG9hZCA9ICgpID0+IHt9LFxuICAgIG9uUmVhZHkgPSBudWxsLFxuICAgIHN0cmF0ZWd5ID0gJ2FmdGVySW50ZXJhY3RpdmUnLFxuICAgIG9uRXJyb3IsXG4gICAgc3R5bGVzaGVldHMsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wc1xuXG4gIC8vIENvbnRleHQgaXMgYXZhaWxhYmxlIG9ubHkgZHVyaW5nIFNTUlxuICBjb25zdCB7IHVwZGF0ZVNjcmlwdHMsIHNjcmlwdHMsIGdldElzU3NyLCBhcHBEaXIsIG5vbmNlIH0gPVxuICAgIHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuXG4gIC8qKlxuICAgKiAtIEZpcnN0IG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhc24ndCBsb2FkZWQgeWV0IChub3QgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgc2tpcHBlZCwgc2V0IGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCB0byB0cnVlXG4gICAqICAgMy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgIDQuIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgICAgIE9uY2UgdGhlIHNjcmlwdCBpcyBsb2FkZWQsIHRoZSBvbkxvYWQgYW5kIG9uUmVhZHkgd2lsbCBiZSBjYWxsZWQgYnkgdGhlblxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cbiAgICogICA1LiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA4LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqXG4gICAqIC0gU2Vjb25kIG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCAoZm91bmQgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgY2FsbGVkLCBzZXQgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IHRvIHRydWVcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgNC4gVGhlIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZCwgbG9hZFNjcmlwdCBiYWlscyBvdXRcbiAgICogICBbSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCAvIGlzIHdyYXBwZWQgaW4gPE9mZlNjcmVlbiAvPiBjb21wb25lbnRdXG4gICAqICAgNS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlcyBhZ2FpblxuICAgKiAgIDYuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcbiAgICogICA3LiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgOC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKi9cbiAgY29uc3QgaGFzT25SZWFkeUVmZmVjdENhbGxlZCA9IHVzZVJlZihmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjXG4gICAgaWYgKCFoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQpIHtcbiAgICAgIC8vIFJ1biBvblJlYWR5IGlmIHNjcmlwdCBoYXMgbG9hZGVkIGJlZm9yZSBidXQgY29tcG9uZW50IGlzIHJlLW1vdW50ZWRcbiAgICAgIGlmIChvblJlYWR5ICYmIGNhY2hlS2V5ICYmIExvYWRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9uUmVhZHkoKVxuICAgICAgfVxuXG4gICAgICBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlXG4gICAgfVxuICB9LCBbb25SZWFkeSwgaWQsIHNyY10pXG5cbiAgY29uc3QgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCA9IHVzZVJlZihmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xuICAgICAgICBsb2FkU2NyaXB0KHByb3BzKVxuICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XG4gICAgICAgIGxvYWRMYXp5U2NyaXB0KHByb3BzKVxuICAgICAgfVxuXG4gICAgICBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlXG4gICAgfVxuICB9LCBbcHJvcHMsIHN0cmF0ZWd5XSlcblxuICBpZiAoc3RyYXRlZ3kgPT09ICdiZWZvcmVJbnRlcmFjdGl2ZScgfHwgc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XG4gICAgaWYgKHVwZGF0ZVNjcmlwdHMpIHtcbiAgICAgIHNjcmlwdHNbc3RyYXRlZ3ldID0gKHNjcmlwdHNbc3RyYXRlZ3ldIHx8IFtdKS5jb25jYXQoW1xuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3JjLFxuICAgICAgICAgIG9uTG9hZCxcbiAgICAgICAgICBvblJlYWR5LFxuICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICAgIHVwZGF0ZVNjcmlwdHMoc2NyaXB0cylcbiAgICB9IGVsc2UgaWYgKGdldElzU3NyICYmIGdldElzU3NyKCkpIHtcbiAgICAgIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWQgZHVyaW5nIFNTUlxuICAgICAgTG9hZENhY2hlLmFkZChpZCB8fCBzcmMpXG4gICAgfSBlbHNlIGlmIChnZXRJc1NzciAmJiAhZ2V0SXNTc3IoKSkge1xuICAgICAgbG9hZFNjcmlwdChwcm9wcylcbiAgICB9XG4gIH1cblxuICAvLyBGb3IgdGhlIGFwcCBkaXJlY3RvcnksIHdlIG5lZWQgUmVhY3QgRmxvYXQgdG8gcHJlbG9hZCB0aGVzZSBzY3JpcHRzLlxuICBpZiAoYXBwRGlyKSB7XG4gICAgLy8gSW5qZWN0aW5nIHN0eWxlc2hlZXRzIGhlcmUgaGFuZGxlcyBiZWZvcmVJbnRlcmFjdGl2ZSBhbmQgd29ya2VyIHNjcmlwdHMgY29ycmVjdGx5XG4gICAgLy8gRm9yIG90aGVyIHN0cmF0ZWdpZXMgaW5qZWN0aW5nIGhlcmUgZW5zdXJlcyBjb3JyZWN0IHN0eWxlc2hlZXQgb3JkZXJcbiAgICAvLyBSZWFjdERPTS5wcmVpbml0IGhhbmRsZXMgbG9hZGluZyB0aGUgc3R5bGVzIGluIHRoZSBjb3JyZWN0IG9yZGVyLFxuICAgIC8vIGFsc28gZW5zdXJlcyB0aGUgc3R5bGVzaGVldCBpcyBsb2FkZWQgb25seSBvbmNlIGFuZCBpbiBhIGNvbnNpc3RlbnQgbWFubmVyXG4gICAgLy9cbiAgICAvLyBDYXNlIDE6IFN0eWxlcyBmb3IgYmVmb3JlSW50ZXJhY3RpdmUvd29ya2VyIHdpdGggYXBwRGlyIC0gaGFuZGxlZCBoZXJlXG4gICAgLy8gQ2FzZSAyOiBTdHlsZXMgZm9yIGJlZm9yZUludGVyYWN0aXZlL3dvcmtlciB3aXRoIHBhZ2VzIGRpciAtIE5vdCBoYW5kbGVkIHlldFxuICAgIC8vIENhc2UgMzogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBhcHBEaXIgLSBoYW5kbGVkIGhlcmVcbiAgICAvLyBDYXNlIDQ6IFN0eWxlcyBmb3IgYWZ0ZXJJbnRlcmFjdGl2ZS9sYXp5T25sb2FkIHdpdGggcGFnZXMgZGlyIC0gaGFuZGxlZCBpbiBpbnNlcnRTdHlsZXNoZWV0cyBmdW5jdGlvblxuICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgc3R5bGVzaGVldHMuZm9yRWFjaCgoc3R5bGVTcmMpID0+IHtcbiAgICAgICAgUmVhY3RET00ucHJlaW5pdChzdHlsZVNyYywgeyBhczogJ3N0eWxlJyB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBCZWZvcmUgaW50ZXJhY3RpdmUgc2NyaXB0cyBuZWVkIHRvIGJlIGxvYWRlZCBieSBOZXh0LmpzJyBydW50aW1lIGluc3RlYWRcbiAgICAvLyBvZiBuYXRpdmUgPHNjcmlwdD4gdGFncywgYmVjYXVzZSB0aGV5IG5vIGxvbmdlciBoYXZlIGBkZWZlcmAuXG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYmVmb3JlSW50ZXJhY3RpdmUnKSB7XG4gICAgICBpZiAoIXNyYykge1xuICAgICAgICAvLyBGb3IgaW5saW5lZCBzY3JpcHRzLCB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYGNoaWxkcmVuYC5cbiAgICAgICAgaWYgKHJlc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgICAgICAgIC8vIENhc3Rpbmcgc2luY2UgbGliLmRvbS5kLnRzIGRvZXNuJ3QgaGF2ZSBUcnVzdGVkSFRNTCB5ZXQuXG4gICAgICAgICAgcmVzdFByb3BzLmNoaWxkcmVuID0gcmVzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXG4gICAgICAgICAgICAuX19odG1sIGFzIHN0cmluZ1xuICAgICAgICAgIGRlbGV0ZSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHNjcmlwdFxuICAgICAgICAgICAgbm9uY2U9e25vbmNlfVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcbiAgICAgICAgICAgICAgX19odG1sOiBgKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goJHtKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB7IC4uLnJlc3RQcm9wcywgaWQgfSxcbiAgICAgICAgICAgICAgXSl9KWAsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgUmVhY3RET00ucHJlbG9hZChcbiAgICAgICAgICBzcmMsXG4gICAgICAgICAgcmVzdFByb3BzLmludGVncml0eVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcmVzdFByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHsgYXM6ICdzY3JpcHQnLCBub25jZSwgY3Jvc3NPcmlnaW46IHJlc3RQcm9wcy5jcm9zc09yaWdpbiB9XG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8c2NyaXB0XG4gICAgICAgICAgICBub25jZT17bm9uY2V9XG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgICAgICBfX2h0bWw6IGAoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaCgke0pTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgeyAuLi5yZXN0UHJvcHMsIGlkIH0sXG4gICAgICAgICAgICAgIF0pfSlgLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2FmdGVySW50ZXJhY3RpdmUnKSB7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgUmVhY3RET00ucHJlbG9hZChcbiAgICAgICAgICBzcmMsXG4gICAgICAgICAgcmVzdFByb3BzLmludGVncml0eVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcmVzdFByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHsgYXM6ICdzY3JpcHQnLCBub25jZSwgY3Jvc3NPcmlnaW46IHJlc3RQcm9wcy5jcm9zc09yaWdpbiB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NyaXB0LCAnX19uZXh0U2NyaXB0JywgeyB2YWx1ZTogdHJ1ZSB9KVxuXG5leHBvcnQgZGVmYXVsdCBTY3JpcHRcbiJdLCJuYW1lcyI6WyJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwiaW5pdFNjcmlwdExvYWRlciIsIlNjcmlwdENhY2hlIiwiTWFwIiwiTG9hZENhY2hlIiwiU2V0IiwiaW5zZXJ0U3R5bGVzaGVldHMiLCJzdHlsZXNoZWV0cyIsIlJlYWN0RE9NIiwicHJlaW5pdCIsImZvckVhY2giLCJzdHlsZXNoZWV0IiwiYXMiLCJ3aW5kb3ciLCJoZWFkIiwiZG9jdW1lbnQiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJyZWwiLCJocmVmIiwiYXBwZW5kQ2hpbGQiLCJsb2FkU2NyaXB0IiwicHJvcHMiLCJzcmMiLCJpZCIsIm9uTG9hZCIsIm9uUmVhZHkiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImNoaWxkcmVuIiwic3RyYXRlZ3kiLCJvbkVycm9yIiwiY2FjaGVLZXkiLCJoYXMiLCJhZGQiLCJnZXQiLCJ0aGVuIiwiYWZ0ZXJMb2FkIiwiZWwiLCJsb2FkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJjYWxsIiwiY2F0Y2giLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJ0ZXh0Q29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJzZXQiLCJzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIiwic2V0QXR0cmlidXRlIiwiYm9keSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJsb2FkTGF6eVNjcmlwdCIsInJlYWR5U3RhdGUiLCJhZGRCZWZvcmVJbnRlcmFjdGl2ZVRvQ2FjaGUiLCJzY3JpcHRzIiwicXVlcnlTZWxlY3RvckFsbCIsInNjcmlwdCIsImdldEF0dHJpYnV0ZSIsInNjcmlwdExvYWRlckl0ZW1zIiwiU2NyaXB0IiwicmVzdFByb3BzIiwidXBkYXRlU2NyaXB0cyIsImdldElzU3NyIiwiYXBwRGlyIiwibm9uY2UiLCJ1c2VDb250ZXh0IiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaGFzT25SZWFkeUVmZmVjdENhbGxlZCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkIiwiY29uY2F0Iiwic3R5bGVTcmMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJlbG9hZCIsImludGVncml0eSIsImNyb3NzT3JpZ2luIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/set-attributes-from-props.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/set-attributes-from-props.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setAttributesFromProps\", ({\n    enumerable: true,\n    get: function() {\n        return setAttributesFromProps;\n    }\n}));\nconst DOMAttributeNames = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv',\n    noModule: 'noModule'\n};\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy',\n    'stylesheets'\n];\nfunction isBooleanScriptAttribute(attr) {\n    return [\n        'async',\n        'defer',\n        'noModule'\n    ].includes(attr);\n}\nfunction setAttributesFromProps(el, props) {\n    for (const [p, value] of Object.entries(props)){\n        if (!props.hasOwnProperty(p)) continue;\n        if (ignoreProps.includes(p)) continue;\n        // we don't render undefined props to the DOM\n        if (value === undefined) {\n            continue;\n        }\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n            // Correctly assign boolean script attributes\n            // https://github.com/vercel/next.js/pull/20748\n            ;\n            el[attr] = !!value;\n        } else {\n            el.setAttribute(attr, String(value));\n        }\n        // Remove falsy non-zero boolean attributes so they are correctly interpreted\n        // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n        if (value === false || el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr) && (!value || value === 'false')) {\n            // Call setAttribute before, as we need to set and unset the attribute to override force async:\n            // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n            el.setAttribute(attr, '');\n            el.removeAttribute(attr);\n        }\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-attributes-from-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NldC1hdHRyaWJ1dGVzLWZyb20tcHJvcHMuanMiLCJtYXBwaW5ncyI6Ijs7OzswREF3QmdCQTs7O2VBQUFBOzs7QUF4QmhCLE1BQU1DLG9CQUE0QztJQUNoREMsZUFBZTtJQUNmQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsV0FBVztJQUNYQyxVQUFVO0FBQ1o7QUFFQSxNQUFNQyxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxTQUFTQyx5QkFDUEMsSUFBWTtJQUVaLE9BQU87UUFBQztRQUFTO1FBQVM7S0FBVyxDQUFDQyxRQUFRLENBQUNEO0FBQ2pEO0FBRU8sU0FBU1QsdUJBQXVCVyxFQUFlLEVBQUVDLEtBQWE7SUFDbkUsS0FBSyxNQUFNLENBQUNDLEdBQUdDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDSixPQUFRO1FBQzlDLElBQUksQ0FBQ0EsTUFBTUssY0FBYyxDQUFDSixJQUFJO1FBQzlCLElBQUlOLFlBQVlHLFFBQVEsQ0FBQ0csSUFBSTtRQUU3Qiw2Q0FBNkM7UUFDN0MsSUFBSUMsVUFBVUksV0FBVztZQUN2QjtRQUNGO1FBRUEsTUFBTVQsT0FBT1IsaUJBQWlCLENBQUNZLEVBQUUsSUFBSUEsRUFBRU0sV0FBVztRQUVsRCxJQUFJUixHQUFHUyxPQUFPLEtBQUssWUFBWVoseUJBQXlCQyxPQUFPO1lBQzdELDZDQUE2QztZQUM3QywrQ0FBK0M7O1lBQzdDRSxFQUF3QixDQUFDRixLQUFLLEdBQUcsQ0FBQyxDQUFDSztRQUN2QyxPQUFPO1lBQ0xILEdBQUdVLFlBQVksQ0FBQ1osTUFBTWEsT0FBT1I7UUFDL0I7UUFFQSw2RUFBNkU7UUFDN0UsMkdBQTJHO1FBQzNHLElBQ0VBLFVBQVUsU0FDVEgsR0FBR1MsT0FBTyxLQUFLLFlBQ2RaLHlCQUF5QkMsU0FDeEIsRUFBQ0ssU0FBU0EsVUFBVSxRQUFNLEVBQzdCO1lBQ0EsK0ZBQStGO1lBQy9GLDJFQUEyRTtZQUMzRUgsR0FBR1UsWUFBWSxDQUFDWixNQUFNO1lBQ3RCRSxHQUFHWSxlQUFlLENBQUNkO1FBQ3JCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxodWdvYVxcRGVza3RvcFxccmVwb3NcXHJlcG9zXFxtZXRhbW9kZWwyYmxvY2tseVxcc3JjXFxjbGllbnRcXHNldC1hdHRyaWJ1dGVzLWZyb20tcHJvcHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRE9NQXR0cmlidXRlTmFtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgaHRtbEZvcjogJ2ZvcicsXG4gIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnLFxuICBub01vZHVsZTogJ25vTW9kdWxlJyxcbn1cblxuY29uc3QgaWdub3JlUHJvcHMgPSBbXG4gICdvbkxvYWQnLFxuICAnb25SZWFkeScsXG4gICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gICdjaGlsZHJlbicsXG4gICdvbkVycm9yJyxcbiAgJ3N0cmF0ZWd5JyxcbiAgJ3N0eWxlc2hlZXRzJyxcbl1cblxuZnVuY3Rpb24gaXNCb29sZWFuU2NyaXB0QXR0cmlidXRlKFxuICBhdHRyOiBzdHJpbmdcbik6IGF0dHIgaXMgJ2FzeW5jJyB8ICdkZWZlcicgfCAnbm9Nb2R1bGUnIHtcbiAgcmV0dXJuIFsnYXN5bmMnLCAnZGVmZXInLCAnbm9Nb2R1bGUnXS5pbmNsdWRlcyhhdHRyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QXR0cmlidXRlc0Zyb21Qcm9wcyhlbDogSFRNTEVsZW1lbnQsIHByb3BzOiBvYmplY3QpIHtcbiAgZm9yIChjb25zdCBbcCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlXG4gICAgaWYgKGlnbm9yZVByb3BzLmluY2x1ZGVzKHApKSBjb250aW51ZVxuXG4gICAgLy8gd2UgZG9uJ3QgcmVuZGVyIHVuZGVmaW5lZCBwcm9wcyB0byB0aGUgRE9NXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYXR0ciA9IERPTUF0dHJpYnV0ZU5hbWVzW3BdIHx8IHAudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKGVsLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmIGlzQm9vbGVhblNjcmlwdEF0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgLy8gQ29ycmVjdGx5IGFzc2lnbiBib29sZWFuIHNjcmlwdCBhdHRyaWJ1dGVzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvcHVsbC8yMDc0OFxuICAgICAgOyhlbCBhcyBIVE1MU2NyaXB0RWxlbWVudClbYXR0cl0gPSAhIXZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBTdHJpbmcodmFsdWUpKVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBmYWxzeSBub24temVybyBib29sZWFuIGF0dHJpYnV0ZXMgc28gdGhleSBhcmUgY29ycmVjdGx5IGludGVycHJldGVkXG4gICAgLy8gKGUuZy4gaWYgd2Ugc2V0IHRoZW0gdG8gZmFsc2UsIHRoaXMgY29lcmNlcyB0byB0aGUgc3RyaW5nIFwiZmFsc2VcIiwgd2hpY2ggdGhlIGJyb3dzZXIgaW50ZXJwcmV0cyBhcyB0cnVlKVxuICAgIGlmIChcbiAgICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgKGVsLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmXG4gICAgICAgIGlzQm9vbGVhblNjcmlwdEF0dHJpYnV0ZShhdHRyKSAmJlxuICAgICAgICAoIXZhbHVlIHx8IHZhbHVlID09PSAnZmFsc2UnKSlcbiAgICApIHtcbiAgICAgIC8vIENhbGwgc2V0QXR0cmlidXRlIGJlZm9yZSwgYXMgd2UgbmVlZCB0byBzZXQgYW5kIHVuc2V0IHRoZSBhdHRyaWJ1dGUgdG8gb3ZlcnJpZGUgZm9yY2UgYXN5bmM6XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzY3JpcHQtZm9yY2UtYXN5bmNcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCAnJylcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInNldEF0dHJpYnV0ZXNGcm9tUHJvcHMiLCJET01BdHRyaWJ1dGVOYW1lcyIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2Iiwibm9Nb2R1bGUiLCJpZ25vcmVQcm9wcyIsImlzQm9vbGVhblNjcmlwdEF0dHJpYnV0ZSIsImF0dHIiLCJpbmNsdWRlcyIsImVsIiwicHJvcHMiLCJwIiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInRhZ05hbWUiLCJzZXRBdHRyaWJ1dGUiLCJTdHJpbmciLCJyZW1vdmVBdHRyaWJ1dGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/set-attributes-from-props.js\n"));

/***/ })

}]);